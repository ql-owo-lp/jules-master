// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.10.1
//   protoc               v4.25.1
// source: jules.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "jules";

export interface Job {
  id: string;
  name: string;
  sessionIds: string[];
  createdAt: string;
  repo: string;
  branch: string;
  autoApproval: boolean;
  background: boolean;
  prompt: string;
  sessionCount: number;
  status: string;
  automationMode: string;
  requirePlanApproval: boolean;
  cronJobId: string;
  profileId: string;
}

export interface Session {
  id: string;
  name: string;
  title: string;
  prompt: string;
  /** JSON string */
  sourceContext: string;
  createTime: string;
  updateTime: string;
  state: string;
  url: string;
  /** JSON string */
  outputs: string;
  requirePlanApproval: boolean;
  automationMode: string;
  lastUpdated: number;
  retryCount: number;
  lastError: string;
  lastInteractionAt: number;
  profileId: string;
}

export interface Settings {
  id: number;
  idlePollInterval: number;
  activePollInterval: number;
  titleTruncateLength: number;
  lineClamp: number;
  sessionItemsPerPage: number;
  jobsPerPage: number;
  defaultSessionCount: number;
  prStatusPollInterval: number;
  theme: string;
  historyPromptsCount: number;
  autoApprovalEnabled: boolean;
  autoApprovalInterval: number;
  autoRetryEnabled: boolean;
  autoRetryMessage: string;
  autoContinueEnabled: boolean;
  autoContinueMessage: string;
  sessionCacheInProgressInterval: number;
  sessionCacheCompletedNoPrInterval: number;
  sessionCachePendingApprovalInterval: number;
  sessionCacheMaxAgeDays: number;
  autoDeleteStaleBranches: boolean;
  autoDeleteStaleBranchesAfterDays: number;
  autoDeleteStaleBranchesInterval: number;
  checkFailingActionsEnabled: boolean;
  checkFailingActionsInterval: number;
  checkFailingActionsThreshold: number;
  closePrOnConflictEnabled: boolean;
  autoCloseStaleConflictedPrs: boolean;
  staleConflictedPrsDurationDays: number;
  minSessionInteractionInterval: number;
  retryTimeout: number;
  profileId: string;
}

export interface ListJobsRequest {
  profileId: string;
  pageSize: number;
  pageToken: string;
}

export interface ListJobsResponse {
  jobs: Job[];
  nextPageToken: string;
}

export interface CreateJobRequest {
  job: Job | undefined;
}

export interface GetJobRequest {
  id: string;
}

export interface ListSessionsRequest {
  profileId: string;
  pageSize: number;
  pageToken: string;
}

export interface ListSessionsResponse {
  sessions: Session[];
  nextPageToken: string;
}

export interface CreateSessionRequest {
  session: Session | undefined;
}

export interface GetSessionRequest {
  id: string;
}

export interface UpdateSessionRequest {
  /** Field mask/paths could be added here */
  session: Session | undefined;
}

export interface GetSettingsRequest {
  profileId: string;
}

export interface UpdateSettingsRequest {
  settings: Settings | undefined;
}

function createBaseJob(): Job {
  return {
    id: "",
    name: "",
    sessionIds: [],
    createdAt: "",
    repo: "",
    branch: "",
    autoApproval: false,
    background: false,
    prompt: "",
    sessionCount: 0,
    status: "",
    automationMode: "",
    requirePlanApproval: false,
    cronJobId: "",
    profileId: "",
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.sessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.repo !== "") {
      writer.uint32(42).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(50).string(message.branch);
    }
    if (message.autoApproval !== false) {
      writer.uint32(56).bool(message.autoApproval);
    }
    if (message.background !== false) {
      writer.uint32(64).bool(message.background);
    }
    if (message.prompt !== "") {
      writer.uint32(74).string(message.prompt);
    }
    if (message.sessionCount !== 0) {
      writer.uint32(80).int32(message.sessionCount);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.automationMode !== "") {
      writer.uint32(98).string(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(104).bool(message.requirePlanApproval);
    }
    if (message.cronJobId !== "") {
      writer.uint32(114).string(message.cronJobId);
    }
    if (message.profileId !== "") {
      writer.uint32(122).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.background = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.automationMode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.cronJobId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Job>, I>>(base?: I): Job {
    return Job.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job>, I>>(object: I): Job {
    const message = createBaseJob();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.autoApproval = object.autoApproval ?? false;
    message.background = object.background ?? false;
    message.prompt = object.prompt ?? "";
    message.sessionCount = object.sessionCount ?? 0;
    message.status = object.status ?? "";
    message.automationMode = object.automationMode ?? "";
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.cronJobId = object.cronJobId ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseSession(): Session {
  return {
    id: "",
    name: "",
    title: "",
    prompt: "",
    sourceContext: "",
    createTime: "",
    updateTime: "",
    state: "",
    url: "",
    outputs: "",
    requirePlanApproval: false,
    automationMode: "",
    lastUpdated: 0,
    retryCount: 0,
    lastError: "",
    lastInteractionAt: 0,
    profileId: "",
  };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.prompt !== "") {
      writer.uint32(34).string(message.prompt);
    }
    if (message.sourceContext !== "") {
      writer.uint32(42).string(message.sourceContext);
    }
    if (message.createTime !== "") {
      writer.uint32(50).string(message.createTime);
    }
    if (message.updateTime !== "") {
      writer.uint32(58).string(message.updateTime);
    }
    if (message.state !== "") {
      writer.uint32(66).string(message.state);
    }
    if (message.url !== "") {
      writer.uint32(74).string(message.url);
    }
    if (message.outputs !== "") {
      writer.uint32(82).string(message.outputs);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(88).bool(message.requirePlanApproval);
    }
    if (message.automationMode !== "") {
      writer.uint32(98).string(message.automationMode);
    }
    if (message.lastUpdated !== 0) {
      writer.uint32(104).int64(message.lastUpdated);
    }
    if (message.retryCount !== 0) {
      writer.uint32(112).int32(message.retryCount);
    }
    if (message.lastError !== "") {
      writer.uint32(122).string(message.lastError);
    }
    if (message.lastInteractionAt !== 0) {
      writer.uint32(128).int64(message.lastInteractionAt);
    }
    if (message.profileId !== "") {
      writer.uint32(138).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sourceContext = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateTime = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.outputs = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.automationMode = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lastUpdated = longToNumber(reader.int64());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lastError = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.lastInteractionAt = longToNumber(reader.int64());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.prompt = object.prompt ?? "";
    message.sourceContext = object.sourceContext ?? "";
    message.createTime = object.createTime ?? "";
    message.updateTime = object.updateTime ?? "";
    message.state = object.state ?? "";
    message.url = object.url ?? "";
    message.outputs = object.outputs ?? "";
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.automationMode = object.automationMode ?? "";
    message.lastUpdated = object.lastUpdated ?? 0;
    message.retryCount = object.retryCount ?? 0;
    message.lastError = object.lastError ?? "";
    message.lastInteractionAt = object.lastInteractionAt ?? 0;
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseSettings(): Settings {
  return {
    id: 0,
    idlePollInterval: 0,
    activePollInterval: 0,
    titleTruncateLength: 0,
    lineClamp: 0,
    sessionItemsPerPage: 0,
    jobsPerPage: 0,
    defaultSessionCount: 0,
    prStatusPollInterval: 0,
    theme: "",
    historyPromptsCount: 0,
    autoApprovalEnabled: false,
    autoApprovalInterval: 0,
    autoRetryEnabled: false,
    autoRetryMessage: "",
    autoContinueEnabled: false,
    autoContinueMessage: "",
    sessionCacheInProgressInterval: 0,
    sessionCacheCompletedNoPrInterval: 0,
    sessionCachePendingApprovalInterval: 0,
    sessionCacheMaxAgeDays: 0,
    autoDeleteStaleBranches: false,
    autoDeleteStaleBranchesAfterDays: 0,
    autoDeleteStaleBranchesInterval: 0,
    checkFailingActionsEnabled: false,
    checkFailingActionsInterval: 0,
    checkFailingActionsThreshold: 0,
    closePrOnConflictEnabled: false,
    autoCloseStaleConflictedPrs: false,
    staleConflictedPrsDurationDays: 0,
    minSessionInteractionInterval: 0,
    retryTimeout: 0,
    profileId: "",
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.idlePollInterval !== 0) {
      writer.uint32(16).int32(message.idlePollInterval);
    }
    if (message.activePollInterval !== 0) {
      writer.uint32(24).int32(message.activePollInterval);
    }
    if (message.titleTruncateLength !== 0) {
      writer.uint32(32).int32(message.titleTruncateLength);
    }
    if (message.lineClamp !== 0) {
      writer.uint32(40).int32(message.lineClamp);
    }
    if (message.sessionItemsPerPage !== 0) {
      writer.uint32(48).int32(message.sessionItemsPerPage);
    }
    if (message.jobsPerPage !== 0) {
      writer.uint32(56).int32(message.jobsPerPage);
    }
    if (message.defaultSessionCount !== 0) {
      writer.uint32(64).int32(message.defaultSessionCount);
    }
    if (message.prStatusPollInterval !== 0) {
      writer.uint32(72).int32(message.prStatusPollInterval);
    }
    if (message.theme !== "") {
      writer.uint32(82).string(message.theme);
    }
    if (message.historyPromptsCount !== 0) {
      writer.uint32(88).int32(message.historyPromptsCount);
    }
    if (message.autoApprovalEnabled !== false) {
      writer.uint32(96).bool(message.autoApprovalEnabled);
    }
    if (message.autoApprovalInterval !== 0) {
      writer.uint32(104).int32(message.autoApprovalInterval);
    }
    if (message.autoRetryEnabled !== false) {
      writer.uint32(112).bool(message.autoRetryEnabled);
    }
    if (message.autoRetryMessage !== "") {
      writer.uint32(122).string(message.autoRetryMessage);
    }
    if (message.autoContinueEnabled !== false) {
      writer.uint32(128).bool(message.autoContinueEnabled);
    }
    if (message.autoContinueMessage !== "") {
      writer.uint32(138).string(message.autoContinueMessage);
    }
    if (message.sessionCacheInProgressInterval !== 0) {
      writer.uint32(144).int32(message.sessionCacheInProgressInterval);
    }
    if (message.sessionCacheCompletedNoPrInterval !== 0) {
      writer.uint32(152).int32(message.sessionCacheCompletedNoPrInterval);
    }
    if (message.sessionCachePendingApprovalInterval !== 0) {
      writer.uint32(160).int32(message.sessionCachePendingApprovalInterval);
    }
    if (message.sessionCacheMaxAgeDays !== 0) {
      writer.uint32(168).int32(message.sessionCacheMaxAgeDays);
    }
    if (message.autoDeleteStaleBranches !== false) {
      writer.uint32(176).bool(message.autoDeleteStaleBranches);
    }
    if (message.autoDeleteStaleBranchesAfterDays !== 0) {
      writer.uint32(184).int32(message.autoDeleteStaleBranchesAfterDays);
    }
    if (message.autoDeleteStaleBranchesInterval !== 0) {
      writer.uint32(192).int32(message.autoDeleteStaleBranchesInterval);
    }
    if (message.checkFailingActionsEnabled !== false) {
      writer.uint32(200).bool(message.checkFailingActionsEnabled);
    }
    if (message.checkFailingActionsInterval !== 0) {
      writer.uint32(208).int32(message.checkFailingActionsInterval);
    }
    if (message.checkFailingActionsThreshold !== 0) {
      writer.uint32(216).int32(message.checkFailingActionsThreshold);
    }
    if (message.closePrOnConflictEnabled !== false) {
      writer.uint32(224).bool(message.closePrOnConflictEnabled);
    }
    if (message.autoCloseStaleConflictedPrs !== false) {
      writer.uint32(232).bool(message.autoCloseStaleConflictedPrs);
    }
    if (message.staleConflictedPrsDurationDays !== 0) {
      writer.uint32(240).int32(message.staleConflictedPrsDurationDays);
    }
    if (message.minSessionInteractionInterval !== 0) {
      writer.uint32(248).int32(message.minSessionInteractionInterval);
    }
    if (message.retryTimeout !== 0) {
      writer.uint32(256).int32(message.retryTimeout);
    }
    if (message.profileId !== "") {
      writer.uint32(802).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idlePollInterval = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activePollInterval = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.titleTruncateLength = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lineClamp = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sessionItemsPerPage = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.jobsPerPage = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.defaultSessionCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.prStatusPollInterval = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.historyPromptsCount = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.autoApprovalEnabled = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.autoApprovalInterval = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.autoRetryEnabled = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.autoRetryMessage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.autoContinueEnabled = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.autoContinueMessage = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.sessionCacheInProgressInterval = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.sessionCacheCompletedNoPrInterval = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.sessionCachePendingApprovalInterval = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.sessionCacheMaxAgeDays = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.autoDeleteStaleBranches = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.autoDeleteStaleBranchesAfterDays = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.autoDeleteStaleBranchesInterval = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.checkFailingActionsEnabled = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.checkFailingActionsInterval = reader.int32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.checkFailingActionsThreshold = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.closePrOnConflictEnabled = reader.bool();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.autoCloseStaleConflictedPrs = reader.bool();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.staleConflictedPrsDurationDays = reader.int32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.minSessionInteractionInterval = reader.int32();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.retryTimeout = reader.int32();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<Settings>, I>>(base?: I): Settings {
    return Settings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settings>, I>>(object: I): Settings {
    const message = createBaseSettings();
    message.id = object.id ?? 0;
    message.idlePollInterval = object.idlePollInterval ?? 0;
    message.activePollInterval = object.activePollInterval ?? 0;
    message.titleTruncateLength = object.titleTruncateLength ?? 0;
    message.lineClamp = object.lineClamp ?? 0;
    message.sessionItemsPerPage = object.sessionItemsPerPage ?? 0;
    message.jobsPerPage = object.jobsPerPage ?? 0;
    message.defaultSessionCount = object.defaultSessionCount ?? 0;
    message.prStatusPollInterval = object.prStatusPollInterval ?? 0;
    message.theme = object.theme ?? "";
    message.historyPromptsCount = object.historyPromptsCount ?? 0;
    message.autoApprovalEnabled = object.autoApprovalEnabled ?? false;
    message.autoApprovalInterval = object.autoApprovalInterval ?? 0;
    message.autoRetryEnabled = object.autoRetryEnabled ?? false;
    message.autoRetryMessage = object.autoRetryMessage ?? "";
    message.autoContinueEnabled = object.autoContinueEnabled ?? false;
    message.autoContinueMessage = object.autoContinueMessage ?? "";
    message.sessionCacheInProgressInterval = object.sessionCacheInProgressInterval ?? 0;
    message.sessionCacheCompletedNoPrInterval = object.sessionCacheCompletedNoPrInterval ?? 0;
    message.sessionCachePendingApprovalInterval = object.sessionCachePendingApprovalInterval ?? 0;
    message.sessionCacheMaxAgeDays = object.sessionCacheMaxAgeDays ?? 0;
    message.autoDeleteStaleBranches = object.autoDeleteStaleBranches ?? false;
    message.autoDeleteStaleBranchesAfterDays = object.autoDeleteStaleBranchesAfterDays ?? 0;
    message.autoDeleteStaleBranchesInterval = object.autoDeleteStaleBranchesInterval ?? 0;
    message.checkFailingActionsEnabled = object.checkFailingActionsEnabled ?? false;
    message.checkFailingActionsInterval = object.checkFailingActionsInterval ?? 0;
    message.checkFailingActionsThreshold = object.checkFailingActionsThreshold ?? 0;
    message.closePrOnConflictEnabled = object.closePrOnConflictEnabled ?? false;
    message.autoCloseStaleConflictedPrs = object.autoCloseStaleConflictedPrs ?? false;
    message.staleConflictedPrsDurationDays = object.staleConflictedPrsDurationDays ?? 0;
    message.minSessionInteractionInterval = object.minSessionInteractionInterval ?? 0;
    message.retryTimeout = object.retryTimeout ?? 0;
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListJobsRequest(): ListJobsRequest {
  return { profileId: "", pageSize: 0, pageToken: "" };
}

export const ListJobsRequest: MessageFns<ListJobsRequest> = {
  encode(message: ListJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListJobsRequest>, I>>(base?: I): ListJobsRequest {
    return ListJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsRequest>, I>>(object: I): ListJobsRequest {
    const message = createBaseListJobsRequest();
    message.profileId = object.profileId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [], nextPageToken: "" };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListJobsResponse>, I>>(base?: I): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsResponse>, I>>(object: I): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateJobRequest(): CreateJobRequest {
  return { job: undefined };
}

export const CreateJobRequest: MessageFns<CreateJobRequest> = {
  encode(message: CreateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.job !== undefined) {
      Job.encode(message.job, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.job = Job.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CreateJobRequest>, I>>(base?: I): CreateJobRequest {
    return CreateJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateJobRequest>, I>>(object: I): CreateJobRequest {
    const message = createBaseCreateJobRequest();
    message.job = (object.job !== undefined && object.job !== null) ? Job.fromPartial(object.job) : undefined;
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { id: "" };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GetJobRequest>, I>>(base?: I): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJobRequest>, I>>(object: I): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { profileId: "", pageSize: 0, pageToken: "" };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(base?: I): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(object: I): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.profileId = object.profileId ?? "";
    message.pageSize = object.pageSize ?? 0;
    message.pageToken = object.pageToken ?? "";
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [], nextPageToken: "" };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(base?: I): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(object: I): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { session: undefined };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { id: "" };
}

export const GetSessionRequest: MessageFns<GetSessionRequest> = {
  encode(message: GetSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseUpdateSessionRequest(): UpdateSessionRequest {
  return { session: undefined };
}

export const UpdateSessionRequest: MessageFns<UpdateSessionRequest> = {
  encode(message: UpdateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      Session.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = Session.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(base?: I): UpdateSessionRequest {
    return UpdateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(object: I): UpdateSessionRequest {
    const message = createBaseUpdateSessionRequest();
    message.session = (object.session !== undefined && object.session !== null)
      ? Session.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseGetSettingsRequest(): GetSettingsRequest {
  return { profileId: "" };
}

export const GetSettingsRequest: MessageFns<GetSettingsRequest> = {
  encode(message: GetSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<GetSettingsRequest>, I>>(base?: I): GetSettingsRequest {
    return GetSettingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSettingsRequest>, I>>(object: I): GetSettingsRequest {
    const message = createBaseGetSettingsRequest();
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
  return { settings: undefined };
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
  encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(base?: I): UpdateSettingsRequest {
    return UpdateSettingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(object: I): UpdateSettingsRequest {
    const message = createBaseUpdateSettingsRequest();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

export type JobServiceDefinition = typeof JobServiceDefinition;
export const JobServiceDefinition = {
  name: "JobService",
  fullName: "jules.JobService",
  methods: {
    listJobs: {
      name: "ListJobs",
      requestType: ListJobsRequest,
      requestStream: false,
      responseType: ListJobsResponse,
      responseStream: false,
      options: {},
    },
    createJob: {
      name: "CreateJob",
      requestType: CreateJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {},
    },
    getJob: {
      name: "GetJob",
      requestType: GetJobRequest,
      requestStream: false,
      responseType: Job,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface JobServiceImplementation<CallContextExt = {}> {
  listJobs(request: ListJobsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ListJobsResponse>>;
  createJob(request: CreateJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
  getJob(request: GetJobRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Job>>;
}

export interface JobServiceClient<CallOptionsExt = {}> {
  listJobs(request: DeepPartial<ListJobsRequest>, options?: CallOptions & CallOptionsExt): Promise<ListJobsResponse>;
  createJob(request: DeepPartial<CreateJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
  getJob(request: DeepPartial<GetJobRequest>, options?: CallOptions & CallOptionsExt): Promise<Job>;
}

export type SessionServiceDefinition = typeof SessionServiceDefinition;
export const SessionServiceDefinition = {
  name: "SessionService",
  fullName: "jules.SessionService",
  methods: {
    listSessions: {
      name: "ListSessions",
      requestType: ListSessionsRequest,
      requestStream: false,
      responseType: ListSessionsResponse,
      responseStream: false,
      options: {},
    },
    createSession: {
      name: "CreateSession",
      requestType: CreateSessionRequest,
      requestStream: false,
      responseType: Session,
      responseStream: false,
      options: {},
    },
    getSession: {
      name: "GetSession",
      requestType: GetSessionRequest,
      requestStream: false,
      responseType: Session,
      responseStream: false,
      options: {},
    },
    updateSession: {
      name: "UpdateSession",
      requestType: UpdateSessionRequest,
      requestStream: false,
      responseType: Session,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SessionServiceImplementation<CallContextExt = {}> {
  listSessions(
    request: ListSessionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListSessionsResponse>>;
  createSession(request: CreateSessionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Session>>;
  getSession(request: GetSessionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Session>>;
  updateSession(request: UpdateSessionRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Session>>;
}

export interface SessionServiceClient<CallOptionsExt = {}> {
  listSessions(
    request: DeepPartial<ListSessionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListSessionsResponse>;
  createSession(request: DeepPartial<CreateSessionRequest>, options?: CallOptions & CallOptionsExt): Promise<Session>;
  getSession(request: DeepPartial<GetSessionRequest>, options?: CallOptions & CallOptionsExt): Promise<Session>;
  updateSession(request: DeepPartial<UpdateSessionRequest>, options?: CallOptions & CallOptionsExt): Promise<Session>;
}

export type SettingsServiceDefinition = typeof SettingsServiceDefinition;
export const SettingsServiceDefinition = {
  name: "SettingsService",
  fullName: "jules.SettingsService",
  methods: {
    getSettings: {
      name: "GetSettings",
      requestType: GetSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {},
    },
    updateSettings: {
      name: "UpdateSettings",
      requestType: UpdateSettingsRequest,
      requestStream: false,
      responseType: Settings,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface SettingsServiceImplementation<CallContextExt = {}> {
  getSettings(request: GetSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
  updateSettings(request: UpdateSettingsRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Settings>>;
}

export interface SettingsServiceClient<CallOptionsExt = {}> {
  getSettings(request: DeepPartial<GetSettingsRequest>, options?: CallOptions & CallOptionsExt): Promise<Settings>;
  updateSettings(
    request: DeepPartial<UpdateSettingsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Settings>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
