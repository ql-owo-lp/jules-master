name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  backend-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23.1"

      - name: Install Protoc
        run: |
          mkdir -p $HOME/.local/bin
          make install-protoc
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Run Backend Tests
        run: make test-backend

  test:
    timeout-minutes: 20
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Install pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9

      - name: Install Dependencies
        working-directory: ./ui
        run: pnpm install --frozen-lockfile

      - name: Run Unit Tests
        working-directory: ./ui
        run: pnpm run test:unit

  e2e:
    timeout-minutes: 20
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build Production Image
      - name: Build Production Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: nextn-app:latest

      # Build Test Runner Image (reusing Dockerfile.test)
      - name: Build Test Runner Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./ui/Dockerfile.test
          push: false
          load: true
          tags: jules-test:latest

      # Start Production App with Shared Volume
      - name: Start Production App
        run: |
          docker volume create shared-data
          # Run production app with shared volume for DB
          docker run -d \
            --name nextn-prod \
            --network host \
            -e PORT=9002 \
            -e DATABASE_URL=/app/data/sqlite.db \
            -v shared-data:/app/data \
            -e MOCK_API=true \
            -e JULES_API_KEY=mock-api-key \
            -e HYBRID_MOCK=true \
            nextn-app:latest

          # Initial wait for container
          sleep 5

      # Run Tests
      - name: Run E2E Tests
        run: |
          # 1. Seed the DB using the test runner (mounting the same volume)
          # We use the test runner because it has the tsx/scripts needed for seeding
          docker run --rm \
            --network host \
            -v shared-data:/app/data \
            -e DATABASE_URL=/app/data/sqlite.db \
            --entrypoint /bin/sh \
            jules-test:latest \
            -c "npx tsx scripts/seed-e2e.ts"

          # 2. Run Playwright Tests against network host (localhost:9002)
          docker run --rm \
            --network host \
            -v shared-data:/app/data \
            -e DATABASE_URL=/app/data/sqlite.db \
            -e TEST_TARGET_URL=http://localhost:9002 \
            -e TEST_SKIP_WEBSERVER=true \
            -e CI=true \
            -e MOCK_API=true \
            -e JULES_API_KEY=mock-api-key \
            jules-test:latest \
            pnpm run test:e2e

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: ui/playwright-report/
          retention-days: 30

  ci-success:
    runs-on: ubuntu-slim
    needs: [backend-test, test, e2e]
    if: always()
    permissions:
      contents: write
      pull-requests: write
      actions: read
    steps:
      - name: Install gh CLI
        run: |
          install_dependencies() {
            if ! command -v curl &> /dev/null; then
              echo "curl not found. Installing..."
              if command -v apt-get &> /dev/null; then
                sudo apt-get update && sudo apt-get install -y curl ca-certificates
              elif command -v apk &> /dev/null; then
                sudo apk add --no-cache curl ca-certificates
              elif command -v yum &> /dev/null; then
                sudo yum install -y curl ca-certificates
              elif command -v dnf &> /dev/null; then
                sudo dnf install -y curl ca-certificates
              else
                echo "Could not find package manager to install curl. Trying to proceed..."
              fi
            fi
          }

          if ! command -v gh &> /dev/null; then
            echo "gh not found. Installing..."
            install_dependencies

            GH_VERSION="2.65.0"
            ARCH=$(uname -m)
            case $ARCH in
              x86_64) ARCH_STR="amd64" ;;
              aarch64) ARCH_STR="arm64" ;;
              *) echo "Unsupported arch: $ARCH"; exit 1 ;;
            esac

            mkdir -p /tmp/gh-install
            if command -v curl &> /dev/null; then
              curl -fsSL https://github.com/cli/cli/releases/download/v${GH_VERSION}/gh_${GH_VERSION}_linux_${ARCH_STR}.tar.gz | tar xz -C /tmp/gh-install
            elif command -v wget &> /dev/null; then
              wget -qO- https://github.com/cli/cli/releases/download/v${GH_VERSION}/gh_${GH_VERSION}_linux_${ARCH_STR}.tar.gz | tar xz -C /tmp/gh-install
            else
              echo "Neither curl nor wget found. Cannot install gh."
              exit 1
            fi

            BIN_PATH="/tmp/gh-install/gh_${GH_VERSION}_linux_${ARCH_STR}/bin/gh"

            if [ -w /usr/local/bin ]; then
               cp "$BIN_PATH" /usr/local/bin/
            elif command -v sudo &> /dev/null; then
               sudo cp "$BIN_PATH" /usr/local/bin/
            else
               mkdir -p "$HOME/.local/bin"
               cp "$BIN_PATH" "$HOME/.local/bin/"
               echo "$HOME/.local/bin" >> $GITHUB_PATH
            fi

            rm -rf /tmp/gh-install
            echo "gh installed successfully."
          else
            echo "gh is already installed."
          fi

      - name: Auto-Squash
        if: github.event_name == 'pull_request'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh pr merge --auto --squash "${{ github.event.pull_request.html_url }}" || echo "Failed to enable auto-merge (check permissions/settings)"

      - name: Check Results and Comment
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.ORG_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            // 1. Check for Failures
            const needs = ${{ toJson(needs) }};
            const failedJobNames = Object.keys(needs).filter(key => needs[key].result === 'failure' || needs[key].result === 'cancelled');
            const { owner, repo } = context.repo;
            const run_id = context.runId;
            const run_url = `https://github.com/${owner}/${repo}/actions/runs/${run_id}`;
            const pull_number = context.issue.number;

            if (failedJobNames.length === 0) {
              console.log('All required jobs passed successfully (or were skipped).');
              return;
            }

            // 2. Prepare Comment Logic (only if PR)
            if (pull_number) {
              let failuresDetails = [];
              try {
                // We use github.rest instead of github.actions for v7 compat if needed, but octokit is global
                // List jobs to find step failures
                const jobsResponse = await github.rest.actions.listJobsForWorkflowRun({
                  owner,
                  repo,
                  run_id,
                });
                const failedJobs = jobsResponse.data.jobs.filter(job => job.conclusion === 'failure');

                for (const job of failedJobs) {
                   const failedSteps = job.steps
                     .filter(step => step.conclusion === 'failure')
                     .map(step => step.name)
                     .join(', ');
                   const msg = failedSteps ? `${job.name}: Failed at step(s) "${failedSteps}"` : `${job.name}: Failed`;
                   failuresDetails.push(msg);
                }
              } catch (e) {
                console.log('Error fetching job details:', e);
                failuresDetails = failedJobNames.map(name => `${name}: Failed`);
              }

              const list = failuresDetails.map(detail => `- **${detail}**`).join('\n');
              const agentPrompt = `
              Please investigate the failures above.
              1. Check the [Action logs](${run_url}) for the specific error messages (e.g., failed tests, lint errors, build issues).
              2. Analyze the root cause.
              3. Apply fixes to the codebase.
              `;

              const body = `‚ùå **CI Checks Failed**

              The following GitHub Actions checks failed in this run:
              ${list}

              ---
              ${agentPrompt}
              `;

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body
              });
            } else {
              console.log('Not a PR, skipping failure comment.');
            }

            // 3. Fail the workflow
            const msg = 'The following required jobs did not pass: ' + failedJobNames.join(', ');
            core.setFailed(msg);
