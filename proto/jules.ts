// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v5.29.3
// source: jules.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "jules";

export enum Theme {
  THEME_UNSPECIFIED = 0,
  THEME_LIGHT = 1,
  THEME_DARK = 2,
  THEME_SYSTEM = 3,
  UNRECOGNIZED = -1,
}

export function themeFromJSON(object: any): Theme {
  switch (object) {
    case 0:
    case "THEME_UNSPECIFIED":
      return Theme.THEME_UNSPECIFIED;
    case 1:
    case "THEME_LIGHT":
      return Theme.THEME_LIGHT;
    case 2:
    case "THEME_DARK":
      return Theme.THEME_DARK;
    case 3:
    case "THEME_SYSTEM":
      return Theme.THEME_SYSTEM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Theme.UNRECOGNIZED;
  }
}

export function themeToJSON(object: Theme): string {
  switch (object) {
    case Theme.THEME_UNSPECIFIED:
      return "THEME_UNSPECIFIED";
    case Theme.THEME_LIGHT:
      return "THEME_LIGHT";
    case Theme.THEME_DARK:
      return "THEME_DARK";
    case Theme.THEME_SYSTEM:
      return "THEME_SYSTEM";
    case Theme.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AutomationMode {
  AUTOMATION_MODE_UNSPECIFIED = 0,
  AUTO_CREATE_PR = 1,
  UNRECOGNIZED = -1,
}

export function automationModeFromJSON(object: any): AutomationMode {
  switch (object) {
    case 0:
    case "AUTOMATION_MODE_UNSPECIFIED":
      return AutomationMode.AUTOMATION_MODE_UNSPECIFIED;
    case 1:
    case "AUTO_CREATE_PR":
      return AutomationMode.AUTO_CREATE_PR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AutomationMode.UNRECOGNIZED;
  }
}

export function automationModeToJSON(object: AutomationMode): string {
  switch (object) {
    case AutomationMode.AUTOMATION_MODE_UNSPECIFIED:
      return "AUTOMATION_MODE_UNSPECIFIED";
    case AutomationMode.AUTO_CREATE_PR:
      return "AUTO_CREATE_PR";
    case AutomationMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Settings {
  id: number;
  idlePollInterval: number;
  activePollInterval: number;
  titleTruncateLength: number;
  lineClamp: number;
  sessionItemsPerPage: number;
  jobsPerPage: number;
  defaultSessionCount: number;
  prStatusPollInterval: number;
  theme: string;
  autoApprovalInterval: number;
  autoApprovalEnabled: boolean;
  autoRetryEnabled: boolean;
  autoRetryMessage: string;
  autoContinueEnabled: boolean;
  autoContinueMessage: string;
  sessionCacheInProgressInterval: number;
  sessionCacheCompletedNoPrInterval: number;
  sessionCachePendingApprovalInterval: number;
  sessionCacheMaxAgeDays: number;
  autoDeleteStaleBranches: boolean;
  autoDeleteStaleBranchesAfterDays: number;
  checkFailingActionsEnabled: boolean;
  checkFailingActionsInterval: number;
  checkFailingActionsThreshold: number;
  autoCloseStaleConflictedPrs: boolean;
  staleConflictedPrsDurationDays: number;
  historyPromptsCount: number;
  minSessionInteractionInterval: number;
  retryTimeout: number;
  profileId: string;
  maxConcurrentBackgroundWorkers: number;
  /** Opaque API: Use getters for all fields. */
  autoApprovalAllSessions: boolean;
  /** Default: true (handled in service) */
  autoContinueAllSessions: boolean;
  autoMergeEnabled: boolean;
  /** "squash" or "rebase" */
  autoMergeMethod: string;
  autoMergeMessage: string;
  autoCloseOnConflictMessage: string;
  closePrOnConflictEnabled: boolean;
}

export interface GetSettingsRequest {
  profileId: string;
}

export interface UpdateSettingsRequest {
  settings: Settings | undefined;
}

export interface UpdateSettingsResponse {
  success: boolean;
}

export interface Profile {
  id: string;
  name: string;
  /** Using string to match SQLite text/existing API behavior */
  createdAt: string;
}

export interface ListProfilesResponse {
  profiles: Profile[];
}

export interface CreateProfileRequest {
  name: string;
}

export interface DeleteProfileRequest {
  id: string;
}

export interface LogEntry {
  timestamp: string;
  /** "info", "warn", "error" */
  level: string;
  /** Ignoring meta for now as it can be complex ANY */
  message: string;
}

export interface GetLogsRequest {
  /** ISO string */
  since: string;
}

export interface GetLogsResponse {
  logs: LogEntry[];
}

export interface CronJob {
  id: string;
  name: string;
  schedule: string;
  prompt: string;
  repo: string;
  branch: string;
  autoApproval: boolean;
  automationMode: AutomationMode;
  requirePlanApproval: boolean;
  sessionCount: number;
  profileId: string;
  enabled: boolean;
  createdAt: string;
  updatedAt: string;
  lastRunAt: string;
}

export interface ListCronJobsResponse {
  cronJobs: CronJob[];
}

export interface CreateCronJobRequest {
  name: string;
  schedule: string;
  prompt: string;
  repo: string;
  branch: string;
  autoApproval: boolean;
  automationMode: AutomationMode;
  requirePlanApproval: boolean;
  sessionCount: number;
  profileId: string;
}

export interface UpdateCronJobRequest {
  id: string;
  /**
   * Using specific fields for partial updates or a mask would be better,
   * but for simplicity mirroring the TS partial logic, we'll make fields optional/nullable
   */
  name?: string | undefined;
  schedule?: string | undefined;
  prompt?: string | undefined;
  repo?: string | undefined;
  branch?: string | undefined;
  autoApproval?: boolean | undefined;
  automationMode?: AutomationMode | undefined;
  requirePlanApproval?: boolean | undefined;
  sessionCount?: number | undefined;
  enabled?: boolean | undefined;
}

export interface DeleteCronJobRequest {
  id: string;
}

export interface ExecuteCronJobRequest {
  id: string;
}

export interface ToggleCronJobRequest {
  id: string;
  enabled: boolean;
}

export interface Job {
  id: string;
  name: string;
  sessionIds: string[];
  createdAt: string;
  repo: string;
  branch: string;
  autoApproval: boolean;
  background: boolean;
  prompt: string;
  sessionCount: number;
  /** 'PENDING', 'PROCESSING', 'COMPLETED' */
  status: string;
  automationMode: AutomationMode;
  requirePlanApproval: boolean;
  cronJobId: string;
  profileId: string;
}

export interface ListJobsResponse {
  jobs: Job[];
}

export interface GetJobRequest {
  id: string;
}

export interface CreateJobRequest {
  id: string;
  name: string;
  sessionIds: string[];
  createdAt: string;
  repo: string;
  branch: string;
  autoApproval: boolean;
  background: boolean;
  prompt: string;
  sessionCount: number;
  status: string;
  automationMode: AutomationMode;
  requirePlanApproval: boolean;
  cronJobId: string;
  profileId: string;
}

export interface CreateManyJobsRequest {
  jobs: CreateJobRequest[];
}

export interface UpdateJobRequest {
  id: string;
  name?: string | undefined;
  status?: string | undefined;
  repo?: string | undefined;
  branch?: string | undefined;
}

export interface DeleteJobRequest {
  id: string;
}

export interface PredefinedPrompt {
  id: string;
  title: string;
  prompt: string;
  profileId: string;
}

export interface ListPredefinedPromptsResponse {
  prompts: PredefinedPrompt[];
}

export interface GetPromptRequest {
  id: string;
}

export interface CreatePromptRequest {
  id: string;
  title: string;
  prompt: string;
  profileId: string;
}

export interface CreateManyPromptsRequest {
  prompts: CreatePromptRequest[];
}

export interface UpdatePromptRequest {
  id: string;
  title?: string | undefined;
  prompt?: string | undefined;
}

export interface DeletePromptRequest {
  id: string;
}

/** Global Prompt */
export interface GlobalPrompt {
  prompt: string;
}

export interface SaveGlobalPromptRequest {
  prompt: string;
}

/** History Prompts */
export interface HistoryPrompt {
  id: string;
  prompt: string;
  lastUsedAt: string;
  profileId: string;
}

export interface ListHistoryPromptsResponse {
  prompts: HistoryPrompt[];
}

export interface GetRecentRequest {
  limit: number;
}

export interface SaveHistoryPromptRequest {
  prompt: string;
}

/** Repo Prompt */
export interface RepoPrompt {
  repo: string;
  prompt: string;
  profileId: string;
}

export interface GetRepoPromptRequest {
  repo: string;
}

export interface SaveRepoPromptRequest {
  repo: string;
  prompt: string;
}

/** Sessions (Basic def for now to support Jobs) */
export interface Session {
  id: string;
  name: string;
  title: string;
  prompt: string;
  createTime: string;
  updateTime: string;
  state: string;
  url: string;
  /** outputs skipped for brevity/complexity for now */
  requirePlanApproval: boolean;
  automationMode: AutomationMode;
  lastUpdated: number;
  retryCount: number;
  lastError: string;
  lastInteractionAt: number;
  profileId: string;
}

export interface ListSessionsRequest {
  /** Filter by profile */
  profileId: string;
}

export interface ListSessionsResponse {
  sessions: Session[];
}

export interface GetSessionRequest {
  id: string;
}

export interface CreateSessionRequest {
  name: string;
  prompt: string;
  repo: string;
  branch: string;
  profileId: string;
}

export interface UpdateSessionRequest {
  id: string;
}

export interface DeleteSessionRequest {
  id: string;
}

export interface ApprovePlanRequest {
  id: string;
}

export interface SendMessageRequest {
  id: string;
  message: string;
  force: boolean;
}

function createBaseSettings(): Settings {
  return {
    id: 0,
    idlePollInterval: 0,
    activePollInterval: 0,
    titleTruncateLength: 0,
    lineClamp: 0,
    sessionItemsPerPage: 0,
    jobsPerPage: 0,
    defaultSessionCount: 0,
    prStatusPollInterval: 0,
    theme: "",
    autoApprovalInterval: 0,
    autoApprovalEnabled: false,
    autoRetryEnabled: false,
    autoRetryMessage: "",
    autoContinueEnabled: false,
    autoContinueMessage: "",
    sessionCacheInProgressInterval: 0,
    sessionCacheCompletedNoPrInterval: 0,
    sessionCachePendingApprovalInterval: 0,
    sessionCacheMaxAgeDays: 0,
    autoDeleteStaleBranches: false,
    autoDeleteStaleBranchesAfterDays: 0,
    checkFailingActionsEnabled: false,
    checkFailingActionsInterval: 0,
    checkFailingActionsThreshold: 0,
    autoCloseStaleConflictedPrs: false,
    staleConflictedPrsDurationDays: 0,
    historyPromptsCount: 0,
    minSessionInteractionInterval: 0,
    retryTimeout: 0,
    profileId: "",
    maxConcurrentBackgroundWorkers: 0,
    autoApprovalAllSessions: false,
    autoContinueAllSessions: false,
    autoMergeEnabled: false,
    autoMergeMethod: "",
    autoMergeMessage: "",
    autoCloseOnConflictMessage: "",
    closePrOnConflictEnabled: false,
  };
}

export const Settings: MessageFns<Settings> = {
  encode(message: Settings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int64(message.id);
    }
    if (message.idlePollInterval !== 0) {
      writer.uint32(16).int32(message.idlePollInterval);
    }
    if (message.activePollInterval !== 0) {
      writer.uint32(24).int32(message.activePollInterval);
    }
    if (message.titleTruncateLength !== 0) {
      writer.uint32(32).int32(message.titleTruncateLength);
    }
    if (message.lineClamp !== 0) {
      writer.uint32(40).int32(message.lineClamp);
    }
    if (message.sessionItemsPerPage !== 0) {
      writer.uint32(48).int32(message.sessionItemsPerPage);
    }
    if (message.jobsPerPage !== 0) {
      writer.uint32(56).int32(message.jobsPerPage);
    }
    if (message.defaultSessionCount !== 0) {
      writer.uint32(64).int32(message.defaultSessionCount);
    }
    if (message.prStatusPollInterval !== 0) {
      writer.uint32(72).int32(message.prStatusPollInterval);
    }
    if (message.theme !== "") {
      writer.uint32(82).string(message.theme);
    }
    if (message.autoApprovalInterval !== 0) {
      writer.uint32(88).int32(message.autoApprovalInterval);
    }
    if (message.autoApprovalEnabled !== false) {
      writer.uint32(248).bool(message.autoApprovalEnabled);
    }
    if (message.autoRetryEnabled !== false) {
      writer.uint32(96).bool(message.autoRetryEnabled);
    }
    if (message.autoRetryMessage !== "") {
      writer.uint32(106).string(message.autoRetryMessage);
    }
    if (message.autoContinueEnabled !== false) {
      writer.uint32(112).bool(message.autoContinueEnabled);
    }
    if (message.autoContinueMessage !== "") {
      writer.uint32(122).string(message.autoContinueMessage);
    }
    if (message.sessionCacheInProgressInterval !== 0) {
      writer.uint32(128).int32(message.sessionCacheInProgressInterval);
    }
    if (message.sessionCacheCompletedNoPrInterval !== 0) {
      writer.uint32(136).int32(message.sessionCacheCompletedNoPrInterval);
    }
    if (message.sessionCachePendingApprovalInterval !== 0) {
      writer.uint32(144).int32(message.sessionCachePendingApprovalInterval);
    }
    if (message.sessionCacheMaxAgeDays !== 0) {
      writer.uint32(152).int32(message.sessionCacheMaxAgeDays);
    }
    if (message.autoDeleteStaleBranches !== false) {
      writer.uint32(160).bool(message.autoDeleteStaleBranches);
    }
    if (message.autoDeleteStaleBranchesAfterDays !== 0) {
      writer.uint32(168).int32(message.autoDeleteStaleBranchesAfterDays);
    }
    if (message.checkFailingActionsEnabled !== false) {
      writer.uint32(176).bool(message.checkFailingActionsEnabled);
    }
    if (message.checkFailingActionsInterval !== 0) {
      writer.uint32(184).int32(message.checkFailingActionsInterval);
    }
    if (message.checkFailingActionsThreshold !== 0) {
      writer.uint32(192).int32(message.checkFailingActionsThreshold);
    }
    if (message.autoCloseStaleConflictedPrs !== false) {
      writer.uint32(200).bool(message.autoCloseStaleConflictedPrs);
    }
    if (message.staleConflictedPrsDurationDays !== 0) {
      writer.uint32(208).int32(message.staleConflictedPrsDurationDays);
    }
    if (message.historyPromptsCount !== 0) {
      writer.uint32(216).int32(message.historyPromptsCount);
    }
    if (message.minSessionInteractionInterval !== 0) {
      writer.uint32(224).int32(message.minSessionInteractionInterval);
    }
    if (message.retryTimeout !== 0) {
      writer.uint32(232).int32(message.retryTimeout);
    }
    if (message.profileId !== "") {
      writer.uint32(242).string(message.profileId);
    }
    if (message.maxConcurrentBackgroundWorkers !== 0) {
      writer.uint32(256).int32(message.maxConcurrentBackgroundWorkers);
    }
    if (message.autoApprovalAllSessions !== false) {
      writer.uint32(264).bool(message.autoApprovalAllSessions);
    }
    if (message.autoContinueAllSessions !== false) {
      writer.uint32(272).bool(message.autoContinueAllSessions);
    }
    if (message.autoMergeEnabled !== false) {
      writer.uint32(280).bool(message.autoMergeEnabled);
    }
    if (message.autoMergeMethod !== "") {
      writer.uint32(290).string(message.autoMergeMethod);
    }
    if (message.autoMergeMessage !== "") {
      writer.uint32(298).string(message.autoMergeMessage);
    }
    if (message.autoCloseOnConflictMessage !== "") {
      writer.uint32(306).string(message.autoCloseOnConflictMessage);
    }
    if (message.closePrOnConflictEnabled !== false) {
      writer.uint32(312).bool(message.closePrOnConflictEnabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Settings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.idlePollInterval = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activePollInterval = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.titleTruncateLength = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lineClamp = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sessionItemsPerPage = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.jobsPerPage = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.defaultSessionCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.prStatusPollInterval = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.theme = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.autoApprovalInterval = reader.int32();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.autoApprovalEnabled = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.autoRetryEnabled = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.autoRetryMessage = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.autoContinueEnabled = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.autoContinueMessage = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.sessionCacheInProgressInterval = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.sessionCacheCompletedNoPrInterval = reader.int32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.sessionCachePendingApprovalInterval = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.sessionCacheMaxAgeDays = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.autoDeleteStaleBranches = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.autoDeleteStaleBranchesAfterDays = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.checkFailingActionsEnabled = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.checkFailingActionsInterval = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.checkFailingActionsThreshold = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.autoCloseStaleConflictedPrs = reader.bool();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.staleConflictedPrsDurationDays = reader.int32();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.historyPromptsCount = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.minSessionInteractionInterval = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.retryTimeout = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.maxConcurrentBackgroundWorkers = reader.int32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.autoApprovalAllSessions = reader.bool();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.autoContinueAllSessions = reader.bool();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }

          message.autoMergeEnabled = reader.bool();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.autoMergeMethod = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.autoMergeMessage = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.autoCloseOnConflictMessage = reader.string();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }

          message.closePrOnConflictEnabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Settings {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      idlePollInterval: isSet(object.idlePollInterval)
        ? globalThis.Number(object.idlePollInterval)
        : isSet(object.idle_poll_interval)
        ? globalThis.Number(object.idle_poll_interval)
        : 0,
      activePollInterval: isSet(object.activePollInterval)
        ? globalThis.Number(object.activePollInterval)
        : isSet(object.active_poll_interval)
        ? globalThis.Number(object.active_poll_interval)
        : 0,
      titleTruncateLength: isSet(object.titleTruncateLength)
        ? globalThis.Number(object.titleTruncateLength)
        : isSet(object.title_truncate_length)
        ? globalThis.Number(object.title_truncate_length)
        : 0,
      lineClamp: isSet(object.lineClamp)
        ? globalThis.Number(object.lineClamp)
        : isSet(object.line_clamp)
        ? globalThis.Number(object.line_clamp)
        : 0,
      sessionItemsPerPage: isSet(object.sessionItemsPerPage)
        ? globalThis.Number(object.sessionItemsPerPage)
        : isSet(object.session_items_per_page)
        ? globalThis.Number(object.session_items_per_page)
        : 0,
      jobsPerPage: isSet(object.jobsPerPage)
        ? globalThis.Number(object.jobsPerPage)
        : isSet(object.jobs_per_page)
        ? globalThis.Number(object.jobs_per_page)
        : 0,
      defaultSessionCount: isSet(object.defaultSessionCount)
        ? globalThis.Number(object.defaultSessionCount)
        : isSet(object.default_session_count)
        ? globalThis.Number(object.default_session_count)
        : 0,
      prStatusPollInterval: isSet(object.prStatusPollInterval)
        ? globalThis.Number(object.prStatusPollInterval)
        : isSet(object.pr_status_poll_interval)
        ? globalThis.Number(object.pr_status_poll_interval)
        : 0,
      theme: isSet(object.theme) ? globalThis.String(object.theme) : "",
      autoApprovalInterval: isSet(object.autoApprovalInterval)
        ? globalThis.Number(object.autoApprovalInterval)
        : isSet(object.auto_approval_interval)
        ? globalThis.Number(object.auto_approval_interval)
        : 0,
      autoApprovalEnabled: isSet(object.autoApprovalEnabled)
        ? globalThis.Boolean(object.autoApprovalEnabled)
        : isSet(object.auto_approval_enabled)
        ? globalThis.Boolean(object.auto_approval_enabled)
        : false,
      autoRetryEnabled: isSet(object.autoRetryEnabled)
        ? globalThis.Boolean(object.autoRetryEnabled)
        : isSet(object.auto_retry_enabled)
        ? globalThis.Boolean(object.auto_retry_enabled)
        : false,
      autoRetryMessage: isSet(object.autoRetryMessage)
        ? globalThis.String(object.autoRetryMessage)
        : isSet(object.auto_retry_message)
        ? globalThis.String(object.auto_retry_message)
        : "",
      autoContinueEnabled: isSet(object.autoContinueEnabled)
        ? globalThis.Boolean(object.autoContinueEnabled)
        : isSet(object.auto_continue_enabled)
        ? globalThis.Boolean(object.auto_continue_enabled)
        : false,
      autoContinueMessage: isSet(object.autoContinueMessage)
        ? globalThis.String(object.autoContinueMessage)
        : isSet(object.auto_continue_message)
        ? globalThis.String(object.auto_continue_message)
        : "",
      sessionCacheInProgressInterval: isSet(object.sessionCacheInProgressInterval)
        ? globalThis.Number(object.sessionCacheInProgressInterval)
        : isSet(object.session_cache_in_progress_interval)
        ? globalThis.Number(object.session_cache_in_progress_interval)
        : 0,
      sessionCacheCompletedNoPrInterval: isSet(object.sessionCacheCompletedNoPrInterval)
        ? globalThis.Number(object.sessionCacheCompletedNoPrInterval)
        : isSet(object.session_cache_completed_no_pr_interval)
        ? globalThis.Number(object.session_cache_completed_no_pr_interval)
        : 0,
      sessionCachePendingApprovalInterval: isSet(object.sessionCachePendingApprovalInterval)
        ? globalThis.Number(object.sessionCachePendingApprovalInterval)
        : isSet(object.session_cache_pending_approval_interval)
        ? globalThis.Number(object.session_cache_pending_approval_interval)
        : 0,
      sessionCacheMaxAgeDays: isSet(object.sessionCacheMaxAgeDays)
        ? globalThis.Number(object.sessionCacheMaxAgeDays)
        : isSet(object.session_cache_max_age_days)
        ? globalThis.Number(object.session_cache_max_age_days)
        : 0,
      autoDeleteStaleBranches: isSet(object.autoDeleteStaleBranches)
        ? globalThis.Boolean(object.autoDeleteStaleBranches)
        : isSet(object.auto_delete_stale_branches)
        ? globalThis.Boolean(object.auto_delete_stale_branches)
        : false,
      autoDeleteStaleBranchesAfterDays: isSet(object.autoDeleteStaleBranchesAfterDays)
        ? globalThis.Number(object.autoDeleteStaleBranchesAfterDays)
        : isSet(object.auto_delete_stale_branches_after_days)
        ? globalThis.Number(object.auto_delete_stale_branches_after_days)
        : 0,
      checkFailingActionsEnabled: isSet(object.checkFailingActionsEnabled)
        ? globalThis.Boolean(object.checkFailingActionsEnabled)
        : isSet(object.check_failing_actions_enabled)
        ? globalThis.Boolean(object.check_failing_actions_enabled)
        : false,
      checkFailingActionsInterval: isSet(object.checkFailingActionsInterval)
        ? globalThis.Number(object.checkFailingActionsInterval)
        : isSet(object.check_failing_actions_interval)
        ? globalThis.Number(object.check_failing_actions_interval)
        : 0,
      checkFailingActionsThreshold: isSet(object.checkFailingActionsThreshold)
        ? globalThis.Number(object.checkFailingActionsThreshold)
        : isSet(object.check_failing_actions_threshold)
        ? globalThis.Number(object.check_failing_actions_threshold)
        : 0,
      autoCloseStaleConflictedPrs: isSet(object.autoCloseStaleConflictedPrs)
        ? globalThis.Boolean(object.autoCloseStaleConflictedPrs)
        : isSet(object.auto_close_stale_conflicted_prs)
        ? globalThis.Boolean(object.auto_close_stale_conflicted_prs)
        : false,
      staleConflictedPrsDurationDays: isSet(object.staleConflictedPrsDurationDays)
        ? globalThis.Number(object.staleConflictedPrsDurationDays)
        : isSet(object.stale_conflicted_prs_duration_days)
        ? globalThis.Number(object.stale_conflicted_prs_duration_days)
        : 0,
      historyPromptsCount: isSet(object.historyPromptsCount)
        ? globalThis.Number(object.historyPromptsCount)
        : isSet(object.history_prompts_count)
        ? globalThis.Number(object.history_prompts_count)
        : 0,
      minSessionInteractionInterval: isSet(object.minSessionInteractionInterval)
        ? globalThis.Number(object.minSessionInteractionInterval)
        : isSet(object.min_session_interaction_interval)
        ? globalThis.Number(object.min_session_interaction_interval)
        : 0,
      retryTimeout: isSet(object.retryTimeout)
        ? globalThis.Number(object.retryTimeout)
        : isSet(object.retry_timeout)
        ? globalThis.Number(object.retry_timeout)
        : 0,
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      maxConcurrentBackgroundWorkers: isSet(object.maxConcurrentBackgroundWorkers)
        ? globalThis.Number(object.maxConcurrentBackgroundWorkers)
        : isSet(object.max_concurrent_background_workers)
        ? globalThis.Number(object.max_concurrent_background_workers)
        : 0,
      autoApprovalAllSessions: isSet(object.autoApprovalAllSessions)
        ? globalThis.Boolean(object.autoApprovalAllSessions)
        : isSet(object.auto_approval_all_sessions)
        ? globalThis.Boolean(object.auto_approval_all_sessions)
        : false,
      autoContinueAllSessions: isSet(object.autoContinueAllSessions)
        ? globalThis.Boolean(object.autoContinueAllSessions)
        : isSet(object.auto_continue_all_sessions)
        ? globalThis.Boolean(object.auto_continue_all_sessions)
        : false,
      autoMergeEnabled: isSet(object.autoMergeEnabled)
        ? globalThis.Boolean(object.autoMergeEnabled)
        : isSet(object.auto_merge_enabled)
        ? globalThis.Boolean(object.auto_merge_enabled)
        : false,
      autoMergeMethod: isSet(object.autoMergeMethod)
        ? globalThis.String(object.autoMergeMethod)
        : isSet(object.auto_merge_method)
        ? globalThis.String(object.auto_merge_method)
        : "",
      autoMergeMessage: isSet(object.autoMergeMessage)
        ? globalThis.String(object.autoMergeMessage)
        : isSet(object.auto_merge_message)
        ? globalThis.String(object.auto_merge_message)
        : "",
      autoCloseOnConflictMessage: isSet(object.autoCloseOnConflictMessage)
        ? globalThis.String(object.autoCloseOnConflictMessage)
        : isSet(object.auto_close_on_conflict_message)
        ? globalThis.String(object.auto_close_on_conflict_message)
        : "",
      closePrOnConflictEnabled: isSet(object.closePrOnConflictEnabled)
        ? globalThis.Boolean(object.closePrOnConflictEnabled)
        : isSet(object.close_pr_on_conflict_enabled)
        ? globalThis.Boolean(object.close_pr_on_conflict_enabled)
        : false,
    };
  },

  toJSON(message: Settings): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.idlePollInterval !== 0) {
      obj.idlePollInterval = Math.round(message.idlePollInterval);
    }
    if (message.activePollInterval !== 0) {
      obj.activePollInterval = Math.round(message.activePollInterval);
    }
    if (message.titleTruncateLength !== 0) {
      obj.titleTruncateLength = Math.round(message.titleTruncateLength);
    }
    if (message.lineClamp !== 0) {
      obj.lineClamp = Math.round(message.lineClamp);
    }
    if (message.sessionItemsPerPage !== 0) {
      obj.sessionItemsPerPage = Math.round(message.sessionItemsPerPage);
    }
    if (message.jobsPerPage !== 0) {
      obj.jobsPerPage = Math.round(message.jobsPerPage);
    }
    if (message.defaultSessionCount !== 0) {
      obj.defaultSessionCount = Math.round(message.defaultSessionCount);
    }
    if (message.prStatusPollInterval !== 0) {
      obj.prStatusPollInterval = Math.round(message.prStatusPollInterval);
    }
    if (message.theme !== "") {
      obj.theme = message.theme;
    }
    if (message.autoApprovalInterval !== 0) {
      obj.autoApprovalInterval = Math.round(message.autoApprovalInterval);
    }
    if (message.autoApprovalEnabled !== false) {
      obj.autoApprovalEnabled = message.autoApprovalEnabled;
    }
    if (message.autoRetryEnabled !== false) {
      obj.autoRetryEnabled = message.autoRetryEnabled;
    }
    if (message.autoRetryMessage !== "") {
      obj.autoRetryMessage = message.autoRetryMessage;
    }
    if (message.autoContinueEnabled !== false) {
      obj.autoContinueEnabled = message.autoContinueEnabled;
    }
    if (message.autoContinueMessage !== "") {
      obj.autoContinueMessage = message.autoContinueMessage;
    }
    if (message.sessionCacheInProgressInterval !== 0) {
      obj.sessionCacheInProgressInterval = Math.round(message.sessionCacheInProgressInterval);
    }
    if (message.sessionCacheCompletedNoPrInterval !== 0) {
      obj.sessionCacheCompletedNoPrInterval = Math.round(message.sessionCacheCompletedNoPrInterval);
    }
    if (message.sessionCachePendingApprovalInterval !== 0) {
      obj.sessionCachePendingApprovalInterval = Math.round(message.sessionCachePendingApprovalInterval);
    }
    if (message.sessionCacheMaxAgeDays !== 0) {
      obj.sessionCacheMaxAgeDays = Math.round(message.sessionCacheMaxAgeDays);
    }
    if (message.autoDeleteStaleBranches !== false) {
      obj.autoDeleteStaleBranches = message.autoDeleteStaleBranches;
    }
    if (message.autoDeleteStaleBranchesAfterDays !== 0) {
      obj.autoDeleteStaleBranchesAfterDays = Math.round(message.autoDeleteStaleBranchesAfterDays);
    }
    if (message.checkFailingActionsEnabled !== false) {
      obj.checkFailingActionsEnabled = message.checkFailingActionsEnabled;
    }
    if (message.checkFailingActionsInterval !== 0) {
      obj.checkFailingActionsInterval = Math.round(message.checkFailingActionsInterval);
    }
    if (message.checkFailingActionsThreshold !== 0) {
      obj.checkFailingActionsThreshold = Math.round(message.checkFailingActionsThreshold);
    }
    if (message.autoCloseStaleConflictedPrs !== false) {
      obj.autoCloseStaleConflictedPrs = message.autoCloseStaleConflictedPrs;
    }
    if (message.staleConflictedPrsDurationDays !== 0) {
      obj.staleConflictedPrsDurationDays = Math.round(message.staleConflictedPrsDurationDays);
    }
    if (message.historyPromptsCount !== 0) {
      obj.historyPromptsCount = Math.round(message.historyPromptsCount);
    }
    if (message.minSessionInteractionInterval !== 0) {
      obj.minSessionInteractionInterval = Math.round(message.minSessionInteractionInterval);
    }
    if (message.retryTimeout !== 0) {
      obj.retryTimeout = Math.round(message.retryTimeout);
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.maxConcurrentBackgroundWorkers !== 0) {
      obj.maxConcurrentBackgroundWorkers = Math.round(message.maxConcurrentBackgroundWorkers);
    }
    if (message.autoApprovalAllSessions !== false) {
      obj.autoApprovalAllSessions = message.autoApprovalAllSessions;
    }
    if (message.autoContinueAllSessions !== false) {
      obj.autoContinueAllSessions = message.autoContinueAllSessions;
    }
    if (message.autoMergeEnabled !== false) {
      obj.autoMergeEnabled = message.autoMergeEnabled;
    }
    if (message.autoMergeMethod !== "") {
      obj.autoMergeMethod = message.autoMergeMethod;
    }
    if (message.autoMergeMessage !== "") {
      obj.autoMergeMessage = message.autoMergeMessage;
    }
    if (message.autoCloseOnConflictMessage !== "") {
      obj.autoCloseOnConflictMessage = message.autoCloseOnConflictMessage;
    }
    if (message.closePrOnConflictEnabled !== false) {
      obj.closePrOnConflictEnabled = message.closePrOnConflictEnabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Settings>, I>>(base?: I): Settings {
    return Settings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Settings>, I>>(object: I): Settings {
    const message = createBaseSettings();
    message.id = object.id ?? 0;
    message.idlePollInterval = object.idlePollInterval ?? 0;
    message.activePollInterval = object.activePollInterval ?? 0;
    message.titleTruncateLength = object.titleTruncateLength ?? 0;
    message.lineClamp = object.lineClamp ?? 0;
    message.sessionItemsPerPage = object.sessionItemsPerPage ?? 0;
    message.jobsPerPage = object.jobsPerPage ?? 0;
    message.defaultSessionCount = object.defaultSessionCount ?? 0;
    message.prStatusPollInterval = object.prStatusPollInterval ?? 0;
    message.theme = object.theme ?? "";
    message.autoApprovalInterval = object.autoApprovalInterval ?? 0;
    message.autoApprovalEnabled = object.autoApprovalEnabled ?? false;
    message.autoRetryEnabled = object.autoRetryEnabled ?? false;
    message.autoRetryMessage = object.autoRetryMessage ?? "";
    message.autoContinueEnabled = object.autoContinueEnabled ?? false;
    message.autoContinueMessage = object.autoContinueMessage ?? "";
    message.sessionCacheInProgressInterval = object.sessionCacheInProgressInterval ?? 0;
    message.sessionCacheCompletedNoPrInterval = object.sessionCacheCompletedNoPrInterval ?? 0;
    message.sessionCachePendingApprovalInterval = object.sessionCachePendingApprovalInterval ?? 0;
    message.sessionCacheMaxAgeDays = object.sessionCacheMaxAgeDays ?? 0;
    message.autoDeleteStaleBranches = object.autoDeleteStaleBranches ?? false;
    message.autoDeleteStaleBranchesAfterDays = object.autoDeleteStaleBranchesAfterDays ?? 0;
    message.checkFailingActionsEnabled = object.checkFailingActionsEnabled ?? false;
    message.checkFailingActionsInterval = object.checkFailingActionsInterval ?? 0;
    message.checkFailingActionsThreshold = object.checkFailingActionsThreshold ?? 0;
    message.autoCloseStaleConflictedPrs = object.autoCloseStaleConflictedPrs ?? false;
    message.staleConflictedPrsDurationDays = object.staleConflictedPrsDurationDays ?? 0;
    message.historyPromptsCount = object.historyPromptsCount ?? 0;
    message.minSessionInteractionInterval = object.minSessionInteractionInterval ?? 0;
    message.retryTimeout = object.retryTimeout ?? 0;
    message.profileId = object.profileId ?? "";
    message.maxConcurrentBackgroundWorkers = object.maxConcurrentBackgroundWorkers ?? 0;
    message.autoApprovalAllSessions = object.autoApprovalAllSessions ?? false;
    message.autoContinueAllSessions = object.autoContinueAllSessions ?? false;
    message.autoMergeEnabled = object.autoMergeEnabled ?? false;
    message.autoMergeMethod = object.autoMergeMethod ?? "";
    message.autoMergeMessage = object.autoMergeMessage ?? "";
    message.autoCloseOnConflictMessage = object.autoCloseOnConflictMessage ?? "";
    message.closePrOnConflictEnabled = object.closePrOnConflictEnabled ?? false;
    return message;
  },
};

function createBaseGetSettingsRequest(): GetSettingsRequest {
  return { profileId: "" };
}

export const GetSettingsRequest: MessageFns<GetSettingsRequest> = {
  encode(message: GetSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSettingsRequest {
    return {
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: GetSettingsRequest): unknown {
    const obj: any = {};
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSettingsRequest>, I>>(base?: I): GetSettingsRequest {
    return GetSettingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSettingsRequest>, I>>(object: I): GetSettingsRequest {
    const message = createBaseGetSettingsRequest();
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseUpdateSettingsRequest(): UpdateSettingsRequest {
  return { settings: undefined };
}

export const UpdateSettingsRequest: MessageFns<UpdateSettingsRequest> = {
  encode(message: UpdateSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settings !== undefined) {
      Settings.encode(message.settings, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settings = Settings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingsRequest {
    return { settings: isSet(object.settings) ? Settings.fromJSON(object.settings) : undefined };
  },

  toJSON(message: UpdateSettingsRequest): unknown {
    const obj: any = {};
    if (message.settings !== undefined) {
      obj.settings = Settings.toJSON(message.settings);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(base?: I): UpdateSettingsRequest {
    return UpdateSettingsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSettingsRequest>, I>>(object: I): UpdateSettingsRequest {
    const message = createBaseUpdateSettingsRequest();
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? Settings.fromPartial(object.settings)
      : undefined;
    return message;
  },
};

function createBaseUpdateSettingsResponse(): UpdateSettingsResponse {
  return { success: false };
}

export const UpdateSettingsResponse: MessageFns<UpdateSettingsResponse> = {
  encode(message: UpdateSettingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSettingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSettingsResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: UpdateSettingsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSettingsResponse>, I>>(base?: I): UpdateSettingsResponse {
    return UpdateSettingsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSettingsResponse>, I>>(object: I): UpdateSettingsResponse {
    const message = createBaseUpdateSettingsResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseProfile(): Profile {
  return { id: "", name: "", createdAt: "" };
}

export const Profile: MessageFns<Profile> = {
  encode(message: Profile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.createdAt !== "") {
      writer.uint32(26).string(message.createdAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Profile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Profile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
    };
  },

  toJSON(message: Profile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Profile>, I>>(base?: I): Profile {
    return Profile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Profile>, I>>(object: I): Profile {
    const message = createBaseProfile();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.createdAt = object.createdAt ?? "";
    return message;
  },
};

function createBaseListProfilesResponse(): ListProfilesResponse {
  return { profiles: [] };
}

export const ListProfilesResponse: MessageFns<ListProfilesResponse> = {
  encode(message: ListProfilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.profiles) {
      Profile.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProfilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProfilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profiles.push(Profile.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProfilesResponse {
    return {
      profiles: globalThis.Array.isArray(object?.profiles) ? object.profiles.map((e: any) => Profile.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListProfilesResponse): unknown {
    const obj: any = {};
    if (message.profiles?.length) {
      obj.profiles = message.profiles.map((e) => Profile.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProfilesResponse>, I>>(base?: I): ListProfilesResponse {
    return ListProfilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProfilesResponse>, I>>(object: I): ListProfilesResponse {
    const message = createBaseListProfilesResponse();
    message.profiles = object.profiles?.map((e) => Profile.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateProfileRequest(): CreateProfileRequest {
  return { name: "" };
}

export const CreateProfileRequest: MessageFns<CreateProfileRequest> = {
  encode(message: CreateProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateProfileRequest {
    return { name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: CreateProfileRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateProfileRequest>, I>>(base?: I): CreateProfileRequest {
    return CreateProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateProfileRequest>, I>>(object: I): CreateProfileRequest {
    const message = createBaseCreateProfileRequest();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDeleteProfileRequest(): DeleteProfileRequest {
  return { id: "" };
}

export const DeleteProfileRequest: MessageFns<DeleteProfileRequest> = {
  encode(message: DeleteProfileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteProfileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProfileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteProfileRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteProfileRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteProfileRequest>, I>>(base?: I): DeleteProfileRequest {
    return DeleteProfileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteProfileRequest>, I>>(object: I): DeleteProfileRequest {
    const message = createBaseDeleteProfileRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return { timestamp: "", level: "", message: "" };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "") {
      writer.uint32(10).string(message.timestamp);
    }
    if (message.level !== "") {
      writer.uint32(18).string(message.level);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.level = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      level: isSet(object.level) ? globalThis.String(object.level) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.level !== "") {
      obj.level = message.level;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogEntry>, I>>(base?: I): LogEntry {
    return LogEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogEntry>, I>>(object: I): LogEntry {
    const message = createBaseLogEntry();
    message.timestamp = object.timestamp ?? "";
    message.level = object.level ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGetLogsRequest(): GetLogsRequest {
  return { since: "" };
}

export const GetLogsRequest: MessageFns<GetLogsRequest> = {
  encode(message: GetLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.since !== "") {
      writer.uint32(10).string(message.since);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.since = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogsRequest {
    return { since: isSet(object.since) ? globalThis.String(object.since) : "" };
  },

  toJSON(message: GetLogsRequest): unknown {
    const obj: any = {};
    if (message.since !== "") {
      obj.since = message.since;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLogsRequest>, I>>(base?: I): GetLogsRequest {
    return GetLogsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLogsRequest>, I>>(object: I): GetLogsRequest {
    const message = createBaseGetLogsRequest();
    message.since = object.since ?? "";
    return message;
  },
};

function createBaseGetLogsResponse(): GetLogsResponse {
  return { logs: [] };
}

export const GetLogsResponse: MessageFns<GetLogsResponse> = {
  encode(message: GetLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      LogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogsResponse {
    return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => LogEntry.fromJSON(e)) : [] };
  },

  toJSON(message: GetLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => LogEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLogsResponse>, I>>(base?: I): GetLogsResponse {
    return GetLogsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLogsResponse>, I>>(object: I): GetLogsResponse {
    const message = createBaseGetLogsResponse();
    message.logs = object.logs?.map((e) => LogEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCronJob(): CronJob {
  return {
    id: "",
    name: "",
    schedule: "",
    prompt: "",
    repo: "",
    branch: "",
    autoApproval: false,
    automationMode: 0,
    requirePlanApproval: false,
    sessionCount: 0,
    profileId: "",
    enabled: false,
    createdAt: "",
    updatedAt: "",
    lastRunAt: "",
  };
}

export const CronJob: MessageFns<CronJob> = {
  encode(message: CronJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.schedule !== "") {
      writer.uint32(26).string(message.schedule);
    }
    if (message.prompt !== "") {
      writer.uint32(34).string(message.prompt);
    }
    if (message.repo !== "") {
      writer.uint32(42).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(50).string(message.branch);
    }
    if (message.autoApproval !== false) {
      writer.uint32(56).bool(message.autoApproval);
    }
    if (message.automationMode !== 0) {
      writer.uint32(64).int32(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(72).bool(message.requirePlanApproval);
    }
    if (message.sessionCount !== 0) {
      writer.uint32(80).int32(message.sessionCount);
    }
    if (message.profileId !== "") {
      writer.uint32(90).string(message.profileId);
    }
    if (message.enabled !== false) {
      writer.uint32(96).bool(message.enabled);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    if (message.lastRunAt !== "") {
      writer.uint32(122).string(message.lastRunAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.lastRunAt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronJob {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      autoApproval: isSet(object.autoApproval)
        ? globalThis.Boolean(object.autoApproval)
        : isSet(object.auto_approval)
        ? globalThis.Boolean(object.auto_approval)
        : false,
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : 0,
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : false,
      sessionCount: isSet(object.sessionCount)
        ? globalThis.Number(object.sessionCount)
        : isSet(object.session_count)
        ? globalThis.Number(object.session_count)
        : 0,
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      updatedAt: isSet(object.updatedAt)
        ? globalThis.String(object.updatedAt)
        : isSet(object.updated_at)
        ? globalThis.String(object.updated_at)
        : "",
      lastRunAt: isSet(object.lastRunAt)
        ? globalThis.String(object.lastRunAt)
        : isSet(object.last_run_at)
        ? globalThis.String(object.last_run_at)
        : "",
    };
  },

  toJSON(message: CronJob): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.autoApproval !== false) {
      obj.autoApproval = message.autoApproval;
    }
    if (message.automationMode !== 0) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.sessionCount !== 0) {
      obj.sessionCount = Math.round(message.sessionCount);
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.updatedAt !== "") {
      obj.updatedAt = message.updatedAt;
    }
    if (message.lastRunAt !== "") {
      obj.lastRunAt = message.lastRunAt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronJob>, I>>(base?: I): CronJob {
    return CronJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronJob>, I>>(object: I): CronJob {
    const message = createBaseCronJob();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.schedule = object.schedule ?? "";
    message.prompt = object.prompt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.autoApproval = object.autoApproval ?? false;
    message.automationMode = object.automationMode ?? 0;
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.sessionCount = object.sessionCount ?? 0;
    message.profileId = object.profileId ?? "";
    message.enabled = object.enabled ?? false;
    message.createdAt = object.createdAt ?? "";
    message.updatedAt = object.updatedAt ?? "";
    message.lastRunAt = object.lastRunAt ?? "";
    return message;
  },
};

function createBaseListCronJobsResponse(): ListCronJobsResponse {
  return { cronJobs: [] };
}

export const ListCronJobsResponse: MessageFns<ListCronJobsResponse> = {
  encode(message: ListCronJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cronJobs) {
      CronJob.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCronJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCronJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cronJobs.push(CronJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCronJobsResponse {
    return {
      cronJobs: globalThis.Array.isArray(object?.cronJobs)
        ? object.cronJobs.map((e: any) => CronJob.fromJSON(e))
        : globalThis.Array.isArray(object?.cron_jobs)
        ? object.cron_jobs.map((e: any) => CronJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListCronJobsResponse): unknown {
    const obj: any = {};
    if (message.cronJobs?.length) {
      obj.cronJobs = message.cronJobs.map((e) => CronJob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCronJobsResponse>, I>>(base?: I): ListCronJobsResponse {
    return ListCronJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCronJobsResponse>, I>>(object: I): ListCronJobsResponse {
    const message = createBaseListCronJobsResponse();
    message.cronJobs = object.cronJobs?.map((e) => CronJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCreateCronJobRequest(): CreateCronJobRequest {
  return {
    name: "",
    schedule: "",
    prompt: "",
    repo: "",
    branch: "",
    autoApproval: false,
    automationMode: 0,
    requirePlanApproval: false,
    sessionCount: 0,
    profileId: "",
  };
}

export const CreateCronJobRequest: MessageFns<CreateCronJobRequest> = {
  encode(message: CreateCronJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schedule !== "") {
      writer.uint32(18).string(message.schedule);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.repo !== "") {
      writer.uint32(34).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(42).string(message.branch);
    }
    if (message.autoApproval !== false) {
      writer.uint32(48).bool(message.autoApproval);
    }
    if (message.automationMode !== 0) {
      writer.uint32(56).int32(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(64).bool(message.requirePlanApproval);
    }
    if (message.sessionCount !== 0) {
      writer.uint32(72).int32(message.sessionCount);
    }
    if (message.profileId !== "") {
      writer.uint32(82).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCronJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCronJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCronJobRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      autoApproval: isSet(object.autoApproval)
        ? globalThis.Boolean(object.autoApproval)
        : isSet(object.auto_approval)
        ? globalThis.Boolean(object.auto_approval)
        : false,
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : 0,
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : false,
      sessionCount: isSet(object.sessionCount)
        ? globalThis.Number(object.sessionCount)
        : isSet(object.session_count)
        ? globalThis.Number(object.session_count)
        : 0,
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: CreateCronJobRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.schedule !== "") {
      obj.schedule = message.schedule;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.autoApproval !== false) {
      obj.autoApproval = message.autoApproval;
    }
    if (message.automationMode !== 0) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.sessionCount !== 0) {
      obj.sessionCount = Math.round(message.sessionCount);
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCronJobRequest>, I>>(base?: I): CreateCronJobRequest {
    return CreateCronJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCronJobRequest>, I>>(object: I): CreateCronJobRequest {
    const message = createBaseCreateCronJobRequest();
    message.name = object.name ?? "";
    message.schedule = object.schedule ?? "";
    message.prompt = object.prompt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.autoApproval = object.autoApproval ?? false;
    message.automationMode = object.automationMode ?? 0;
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.sessionCount = object.sessionCount ?? 0;
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseUpdateCronJobRequest(): UpdateCronJobRequest {
  return {
    id: "",
    name: undefined,
    schedule: undefined,
    prompt: undefined,
    repo: undefined,
    branch: undefined,
    autoApproval: undefined,
    automationMode: undefined,
    requirePlanApproval: undefined,
    sessionCount: undefined,
    enabled: undefined,
  };
}

export const UpdateCronJobRequest: MessageFns<UpdateCronJobRequest> = {
  encode(message: UpdateCronJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.schedule !== undefined) {
      writer.uint32(26).string(message.schedule);
    }
    if (message.prompt !== undefined) {
      writer.uint32(34).string(message.prompt);
    }
    if (message.repo !== undefined) {
      writer.uint32(42).string(message.repo);
    }
    if (message.branch !== undefined) {
      writer.uint32(50).string(message.branch);
    }
    if (message.autoApproval !== undefined) {
      writer.uint32(56).bool(message.autoApproval);
    }
    if (message.automationMode !== undefined) {
      writer.uint32(64).int32(message.automationMode);
    }
    if (message.requirePlanApproval !== undefined) {
      writer.uint32(72).bool(message.requirePlanApproval);
    }
    if (message.sessionCount !== undefined) {
      writer.uint32(80).int32(message.sessionCount);
    }
    if (message.enabled !== undefined) {
      writer.uint32(88).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateCronJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCronJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schedule = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateCronJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      schedule: isSet(object.schedule) ? globalThis.String(object.schedule) : undefined,
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : undefined,
      repo: isSet(object.repo) ? globalThis.String(object.repo) : undefined,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
      autoApproval: isSet(object.autoApproval)
        ? globalThis.Boolean(object.autoApproval)
        : isSet(object.auto_approval)
        ? globalThis.Boolean(object.auto_approval)
        : undefined,
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : undefined,
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : undefined,
      sessionCount: isSet(object.sessionCount)
        ? globalThis.Number(object.sessionCount)
        : isSet(object.session_count)
        ? globalThis.Number(object.session_count)
        : undefined,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : undefined,
    };
  },

  toJSON(message: UpdateCronJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.schedule !== undefined) {
      obj.schedule = message.schedule;
    }
    if (message.prompt !== undefined) {
      obj.prompt = message.prompt;
    }
    if (message.repo !== undefined) {
      obj.repo = message.repo;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    if (message.autoApproval !== undefined) {
      obj.autoApproval = message.autoApproval;
    }
    if (message.automationMode !== undefined) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.requirePlanApproval !== undefined) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.sessionCount !== undefined) {
      obj.sessionCount = Math.round(message.sessionCount);
    }
    if (message.enabled !== undefined) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateCronJobRequest>, I>>(base?: I): UpdateCronJobRequest {
    return UpdateCronJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateCronJobRequest>, I>>(object: I): UpdateCronJobRequest {
    const message = createBaseUpdateCronJobRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.schedule = object.schedule ?? undefined;
    message.prompt = object.prompt ?? undefined;
    message.repo = object.repo ?? undefined;
    message.branch = object.branch ?? undefined;
    message.autoApproval = object.autoApproval ?? undefined;
    message.automationMode = object.automationMode ?? undefined;
    message.requirePlanApproval = object.requirePlanApproval ?? undefined;
    message.sessionCount = object.sessionCount ?? undefined;
    message.enabled = object.enabled ?? undefined;
    return message;
  },
};

function createBaseDeleteCronJobRequest(): DeleteCronJobRequest {
  return { id: "" };
}

export const DeleteCronJobRequest: MessageFns<DeleteCronJobRequest> = {
  encode(message: DeleteCronJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteCronJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCronJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteCronJobRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteCronJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteCronJobRequest>, I>>(base?: I): DeleteCronJobRequest {
    return DeleteCronJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteCronJobRequest>, I>>(object: I): DeleteCronJobRequest {
    const message = createBaseDeleteCronJobRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseExecuteCronJobRequest(): ExecuteCronJobRequest {
  return { id: "" };
}

export const ExecuteCronJobRequest: MessageFns<ExecuteCronJobRequest> = {
  encode(message: ExecuteCronJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteCronJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteCronJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteCronJobRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: ExecuteCronJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteCronJobRequest>, I>>(base?: I): ExecuteCronJobRequest {
    return ExecuteCronJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteCronJobRequest>, I>>(object: I): ExecuteCronJobRequest {
    const message = createBaseExecuteCronJobRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseToggleCronJobRequest(): ToggleCronJobRequest {
  return { id: "", enabled: false };
}

export const ToggleCronJobRequest: MessageFns<ToggleCronJobRequest> = {
  encode(message: ToggleCronJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleCronJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleCronJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleCronJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: ToggleCronJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToggleCronJobRequest>, I>>(base?: I): ToggleCronJobRequest {
    return ToggleCronJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleCronJobRequest>, I>>(object: I): ToggleCronJobRequest {
    const message = createBaseToggleCronJobRequest();
    message.id = object.id ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseJob(): Job {
  return {
    id: "",
    name: "",
    sessionIds: [],
    createdAt: "",
    repo: "",
    branch: "",
    autoApproval: false,
    background: false,
    prompt: "",
    sessionCount: 0,
    status: "",
    automationMode: 0,
    requirePlanApproval: false,
    cronJobId: "",
    profileId: "",
  };
}

export const Job: MessageFns<Job> = {
  encode(message: Job, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.sessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.repo !== "") {
      writer.uint32(42).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(50).string(message.branch);
    }
    if (message.autoApproval !== false) {
      writer.uint32(56).bool(message.autoApproval);
    }
    if (message.background !== false) {
      writer.uint32(64).bool(message.background);
    }
    if (message.prompt !== "") {
      writer.uint32(74).string(message.prompt);
    }
    if (message.sessionCount !== 0) {
      writer.uint32(80).int32(message.sessionCount);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.automationMode !== 0) {
      writer.uint32(96).int32(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(104).bool(message.requirePlanApproval);
    }
    if (message.cronJobId !== "") {
      writer.uint32(114).string(message.cronJobId);
    }
    if (message.profileId !== "") {
      writer.uint32(122).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Job {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.background = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.cronJobId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Job {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sessionIds: globalThis.Array.isArray(object?.sessionIds)
        ? object.sessionIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.session_ids)
        ? object.session_ids.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      autoApproval: isSet(object.autoApproval)
        ? globalThis.Boolean(object.autoApproval)
        : isSet(object.auto_approval)
        ? globalThis.Boolean(object.auto_approval)
        : false,
      background: isSet(object.background) ? globalThis.Boolean(object.background) : false,
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      sessionCount: isSet(object.sessionCount)
        ? globalThis.Number(object.sessionCount)
        : isSet(object.session_count)
        ? globalThis.Number(object.session_count)
        : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : 0,
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : false,
      cronJobId: isSet(object.cronJobId)
        ? globalThis.String(object.cronJobId)
        : isSet(object.cron_job_id)
        ? globalThis.String(object.cron_job_id)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: Job): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sessionIds?.length) {
      obj.sessionIds = message.sessionIds;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.autoApproval !== false) {
      obj.autoApproval = message.autoApproval;
    }
    if (message.background !== false) {
      obj.background = message.background;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.sessionCount !== 0) {
      obj.sessionCount = Math.round(message.sessionCount);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.automationMode !== 0) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.cronJobId !== "") {
      obj.cronJobId = message.cronJobId;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Job>, I>>(base?: I): Job {
    return Job.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Job>, I>>(object: I): Job {
    const message = createBaseJob();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.autoApproval = object.autoApproval ?? false;
    message.background = object.background ?? false;
    message.prompt = object.prompt ?? "";
    message.sessionCount = object.sessionCount ?? 0;
    message.status = object.status ?? "";
    message.automationMode = object.automationMode ?? 0;
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.cronJobId = object.cronJobId ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListJobsResponse(): ListJobsResponse {
  return { jobs: [] };
}

export const ListJobsResponse: MessageFns<ListJobsResponse> = {
  encode(message: ListJobsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      Job.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListJobsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListJobsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(Job.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListJobsResponse {
    return { jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => Job.fromJSON(e)) : [] };
  },

  toJSON(message: ListJobsResponse): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => Job.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListJobsResponse>, I>>(base?: I): ListJobsResponse {
    return ListJobsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListJobsResponse>, I>>(object: I): ListJobsResponse {
    const message = createBaseListJobsResponse();
    message.jobs = object.jobs?.map((e) => Job.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetJobRequest(): GetJobRequest {
  return { id: "" };
}

export const GetJobRequest: MessageFns<GetJobRequest> = {
  encode(message: GetJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetJobRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetJobRequest>, I>>(base?: I): GetJobRequest {
    return GetJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetJobRequest>, I>>(object: I): GetJobRequest {
    const message = createBaseGetJobRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateJobRequest(): CreateJobRequest {
  return {
    id: "",
    name: "",
    sessionIds: [],
    createdAt: "",
    repo: "",
    branch: "",
    autoApproval: false,
    background: false,
    prompt: "",
    sessionCount: 0,
    status: "",
    automationMode: 0,
    requirePlanApproval: false,
    cronJobId: "",
    profileId: "",
  };
}

export const CreateJobRequest: MessageFns<CreateJobRequest> = {
  encode(message: CreateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.sessionIds) {
      writer.uint32(26).string(v!);
    }
    if (message.createdAt !== "") {
      writer.uint32(34).string(message.createdAt);
    }
    if (message.repo !== "") {
      writer.uint32(42).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(50).string(message.branch);
    }
    if (message.autoApproval !== false) {
      writer.uint32(56).bool(message.autoApproval);
    }
    if (message.background !== false) {
      writer.uint32(64).bool(message.background);
    }
    if (message.prompt !== "") {
      writer.uint32(74).string(message.prompt);
    }
    if (message.sessionCount !== 0) {
      writer.uint32(80).int32(message.sessionCount);
    }
    if (message.status !== "") {
      writer.uint32(90).string(message.status);
    }
    if (message.automationMode !== 0) {
      writer.uint32(96).int32(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(104).bool(message.requirePlanApproval);
    }
    if (message.cronJobId !== "") {
      writer.uint32(114).string(message.cronJobId);
    }
    if (message.profileId !== "") {
      writer.uint32(122).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.autoApproval = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.background = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.sessionCount = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.cronJobId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      sessionIds: globalThis.Array.isArray(object?.sessionIds)
        ? object.sessionIds.map((e: any) => globalThis.String(e))
        : globalThis.Array.isArray(object?.session_ids)
        ? object.session_ids.map((e: any) => globalThis.String(e))
        : [],
      createdAt: isSet(object.createdAt)
        ? globalThis.String(object.createdAt)
        : isSet(object.created_at)
        ? globalThis.String(object.created_at)
        : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      autoApproval: isSet(object.autoApproval)
        ? globalThis.Boolean(object.autoApproval)
        : isSet(object.auto_approval)
        ? globalThis.Boolean(object.auto_approval)
        : false,
      background: isSet(object.background) ? globalThis.Boolean(object.background) : false,
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      sessionCount: isSet(object.sessionCount)
        ? globalThis.Number(object.sessionCount)
        : isSet(object.session_count)
        ? globalThis.Number(object.session_count)
        : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : 0,
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : false,
      cronJobId: isSet(object.cronJobId)
        ? globalThis.String(object.cronJobId)
        : isSet(object.cron_job_id)
        ? globalThis.String(object.cron_job_id)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: CreateJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.sessionIds?.length) {
      obj.sessionIds = message.sessionIds;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.autoApproval !== false) {
      obj.autoApproval = message.autoApproval;
    }
    if (message.background !== false) {
      obj.background = message.background;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.sessionCount !== 0) {
      obj.sessionCount = Math.round(message.sessionCount);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.automationMode !== 0) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.requirePlanApproval !== false) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.cronJobId !== "") {
      obj.cronJobId = message.cronJobId;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateJobRequest>, I>>(base?: I): CreateJobRequest {
    return CreateJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateJobRequest>, I>>(object: I): CreateJobRequest {
    const message = createBaseCreateJobRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    message.createdAt = object.createdAt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.autoApproval = object.autoApproval ?? false;
    message.background = object.background ?? false;
    message.prompt = object.prompt ?? "";
    message.sessionCount = object.sessionCount ?? 0;
    message.status = object.status ?? "";
    message.automationMode = object.automationMode ?? 0;
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.cronJobId = object.cronJobId ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseCreateManyJobsRequest(): CreateManyJobsRequest {
  return { jobs: [] };
}

export const CreateManyJobsRequest: MessageFns<CreateManyJobsRequest> = {
  encode(message: CreateManyJobsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.jobs) {
      CreateJobRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateManyJobsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateManyJobsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobs.push(CreateJobRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateManyJobsRequest {
    return {
      jobs: globalThis.Array.isArray(object?.jobs) ? object.jobs.map((e: any) => CreateJobRequest.fromJSON(e)) : [],
    };
  },

  toJSON(message: CreateManyJobsRequest): unknown {
    const obj: any = {};
    if (message.jobs?.length) {
      obj.jobs = message.jobs.map((e) => CreateJobRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateManyJobsRequest>, I>>(base?: I): CreateManyJobsRequest {
    return CreateManyJobsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateManyJobsRequest>, I>>(object: I): CreateManyJobsRequest {
    const message = createBaseCreateManyJobsRequest();
    message.jobs = object.jobs?.map((e) => CreateJobRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateJobRequest(): UpdateJobRequest {
  return { id: "", name: undefined, status: undefined, repo: undefined, branch: undefined };
}

export const UpdateJobRequest: MessageFns<UpdateJobRequest> = {
  encode(message: UpdateJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.status !== undefined) {
      writer.uint32(26).string(message.status);
    }
    if (message.repo !== undefined) {
      writer.uint32(34).string(message.repo);
    }
    if (message.branch !== undefined) {
      writer.uint32(42).string(message.branch);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateJobRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      status: isSet(object.status) ? globalThis.String(object.status) : undefined,
      repo: isSet(object.repo) ? globalThis.String(object.repo) : undefined,
      branch: isSet(object.branch) ? globalThis.String(object.branch) : undefined,
    };
  },

  toJSON(message: UpdateJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.status !== undefined) {
      obj.status = message.status;
    }
    if (message.repo !== undefined) {
      obj.repo = message.repo;
    }
    if (message.branch !== undefined) {
      obj.branch = message.branch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateJobRequest>, I>>(base?: I): UpdateJobRequest {
    return UpdateJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateJobRequest>, I>>(object: I): UpdateJobRequest {
    const message = createBaseUpdateJobRequest();
    message.id = object.id ?? "";
    message.name = object.name ?? undefined;
    message.status = object.status ?? undefined;
    message.repo = object.repo ?? undefined;
    message.branch = object.branch ?? undefined;
    return message;
  },
};

function createBaseDeleteJobRequest(): DeleteJobRequest {
  return { id: "" };
}

export const DeleteJobRequest: MessageFns<DeleteJobRequest> = {
  encode(message: DeleteJobRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteJobRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteJobRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteJobRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteJobRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteJobRequest>, I>>(base?: I): DeleteJobRequest {
    return DeleteJobRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteJobRequest>, I>>(object: I): DeleteJobRequest {
    const message = createBaseDeleteJobRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBasePredefinedPrompt(): PredefinedPrompt {
  return { id: "", title: "", prompt: "", profileId: "" };
}

export const PredefinedPrompt: MessageFns<PredefinedPrompt> = {
  encode(message: PredefinedPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.profileId !== "") {
      writer.uint32(34).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PredefinedPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePredefinedPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PredefinedPrompt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: PredefinedPrompt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PredefinedPrompt>, I>>(base?: I): PredefinedPrompt {
    return PredefinedPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PredefinedPrompt>, I>>(object: I): PredefinedPrompt {
    const message = createBasePredefinedPrompt();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.prompt = object.prompt ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListPredefinedPromptsResponse(): ListPredefinedPromptsResponse {
  return { prompts: [] };
}

export const ListPredefinedPromptsResponse: MessageFns<ListPredefinedPromptsResponse> = {
  encode(message: ListPredefinedPromptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prompts) {
      PredefinedPrompt.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPredefinedPromptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPredefinedPromptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompts.push(PredefinedPrompt.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPredefinedPromptsResponse {
    return {
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => PredefinedPrompt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListPredefinedPromptsResponse): unknown {
    const obj: any = {};
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => PredefinedPrompt.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPredefinedPromptsResponse>, I>>(base?: I): ListPredefinedPromptsResponse {
    return ListPredefinedPromptsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPredefinedPromptsResponse>, I>>(
    object: I,
  ): ListPredefinedPromptsResponse {
    const message = createBaseListPredefinedPromptsResponse();
    message.prompts = object.prompts?.map((e) => PredefinedPrompt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetPromptRequest(): GetPromptRequest {
  return { id: "" };
}

export const GetPromptRequest: MessageFns<GetPromptRequest> = {
  encode(message: GetPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetPromptRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetPromptRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetPromptRequest>, I>>(base?: I): GetPromptRequest {
    return GetPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetPromptRequest>, I>>(object: I): GetPromptRequest {
    const message = createBaseGetPromptRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreatePromptRequest(): CreatePromptRequest {
  return { id: "", title: "", prompt: "", profileId: "" };
}

export const CreatePromptRequest: MessageFns<CreatePromptRequest> = {
  encode(message: CreatePromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.prompt !== "") {
      writer.uint32(26).string(message.prompt);
    }
    if (message.profileId !== "") {
      writer.uint32(34).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreatePromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreatePromptRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: CreatePromptRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreatePromptRequest>, I>>(base?: I): CreatePromptRequest {
    return CreatePromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreatePromptRequest>, I>>(object: I): CreatePromptRequest {
    const message = createBaseCreatePromptRequest();
    message.id = object.id ?? "";
    message.title = object.title ?? "";
    message.prompt = object.prompt ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseCreateManyPromptsRequest(): CreateManyPromptsRequest {
  return { prompts: [] };
}

export const CreateManyPromptsRequest: MessageFns<CreateManyPromptsRequest> = {
  encode(message: CreateManyPromptsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prompts) {
      CreatePromptRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateManyPromptsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateManyPromptsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompts.push(CreatePromptRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateManyPromptsRequest {
    return {
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => CreatePromptRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateManyPromptsRequest): unknown {
    const obj: any = {};
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => CreatePromptRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateManyPromptsRequest>, I>>(base?: I): CreateManyPromptsRequest {
    return CreateManyPromptsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateManyPromptsRequest>, I>>(object: I): CreateManyPromptsRequest {
    const message = createBaseCreateManyPromptsRequest();
    message.prompts = object.prompts?.map((e) => CreatePromptRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdatePromptRequest(): UpdatePromptRequest {
  return { id: "", title: undefined, prompt: undefined };
}

export const UpdatePromptRequest: MessageFns<UpdatePromptRequest> = {
  encode(message: UpdatePromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    if (message.prompt !== undefined) {
      writer.uint32(26).string(message.prompt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdatePromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdatePromptRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : undefined,
    };
  },

  toJSON(message: UpdatePromptRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.prompt !== undefined) {
      obj.prompt = message.prompt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdatePromptRequest>, I>>(base?: I): UpdatePromptRequest {
    return UpdatePromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdatePromptRequest>, I>>(object: I): UpdatePromptRequest {
    const message = createBaseUpdatePromptRequest();
    message.id = object.id ?? "";
    message.title = object.title ?? undefined;
    message.prompt = object.prompt ?? undefined;
    return message;
  },
};

function createBaseDeletePromptRequest(): DeletePromptRequest {
  return { id: "" };
}

export const DeletePromptRequest: MessageFns<DeletePromptRequest> = {
  encode(message: DeletePromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeletePromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeletePromptRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeletePromptRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeletePromptRequest>, I>>(base?: I): DeletePromptRequest {
    return DeletePromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeletePromptRequest>, I>>(object: I): DeletePromptRequest {
    const message = createBaseDeletePromptRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseGlobalPrompt(): GlobalPrompt {
  return { prompt: "" };
}

export const GlobalPrompt: MessageFns<GlobalPrompt> = {
  encode(message: GlobalPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlobalPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlobalPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlobalPrompt {
    return { prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "" };
  },

  toJSON(message: GlobalPrompt): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GlobalPrompt>, I>>(base?: I): GlobalPrompt {
    return GlobalPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GlobalPrompt>, I>>(object: I): GlobalPrompt {
    const message = createBaseGlobalPrompt();
    message.prompt = object.prompt ?? "";
    return message;
  },
};

function createBaseSaveGlobalPromptRequest(): SaveGlobalPromptRequest {
  return { prompt: "" };
}

export const SaveGlobalPromptRequest: MessageFns<SaveGlobalPromptRequest> = {
  encode(message: SaveGlobalPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveGlobalPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveGlobalPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveGlobalPromptRequest {
    return { prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "" };
  },

  toJSON(message: SaveGlobalPromptRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveGlobalPromptRequest>, I>>(base?: I): SaveGlobalPromptRequest {
    return SaveGlobalPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveGlobalPromptRequest>, I>>(object: I): SaveGlobalPromptRequest {
    const message = createBaseSaveGlobalPromptRequest();
    message.prompt = object.prompt ?? "";
    return message;
  },
};

function createBaseHistoryPrompt(): HistoryPrompt {
  return { id: "", prompt: "", lastUsedAt: "", profileId: "" };
}

export const HistoryPrompt: MessageFns<HistoryPrompt> = {
  encode(message: HistoryPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    if (message.lastUsedAt !== "") {
      writer.uint32(26).string(message.lastUsedAt);
    }
    if (message.profileId !== "") {
      writer.uint32(34).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoryPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoryPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lastUsedAt = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HistoryPrompt {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      lastUsedAt: isSet(object.lastUsedAt)
        ? globalThis.String(object.lastUsedAt)
        : isSet(object.last_used_at)
        ? globalThis.String(object.last_used_at)
        : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: HistoryPrompt): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.lastUsedAt !== "") {
      obj.lastUsedAt = message.lastUsedAt;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HistoryPrompt>, I>>(base?: I): HistoryPrompt {
    return HistoryPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HistoryPrompt>, I>>(object: I): HistoryPrompt {
    const message = createBaseHistoryPrompt();
    message.id = object.id ?? "";
    message.prompt = object.prompt ?? "";
    message.lastUsedAt = object.lastUsedAt ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListHistoryPromptsResponse(): ListHistoryPromptsResponse {
  return { prompts: [] };
}

export const ListHistoryPromptsResponse: MessageFns<ListHistoryPromptsResponse> = {
  encode(message: ListHistoryPromptsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prompts) {
      HistoryPrompt.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListHistoryPromptsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListHistoryPromptsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompts.push(HistoryPrompt.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListHistoryPromptsResponse {
    return {
      prompts: globalThis.Array.isArray(object?.prompts)
        ? object.prompts.map((e: any) => HistoryPrompt.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListHistoryPromptsResponse): unknown {
    const obj: any = {};
    if (message.prompts?.length) {
      obj.prompts = message.prompts.map((e) => HistoryPrompt.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListHistoryPromptsResponse>, I>>(base?: I): ListHistoryPromptsResponse {
    return ListHistoryPromptsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListHistoryPromptsResponse>, I>>(object: I): ListHistoryPromptsResponse {
    const message = createBaseListHistoryPromptsResponse();
    message.prompts = object.prompts?.map((e) => HistoryPrompt.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRecentRequest(): GetRecentRequest {
  return { limit: 0 };
}

export const GetRecentRequest: MessageFns<GetRecentRequest> = {
  encode(message: GetRecentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.limit !== 0) {
      writer.uint32(8).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRecentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRecentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRecentRequest {
    return { limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0 };
  },

  toJSON(message: GetRecentRequest): unknown {
    const obj: any = {};
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRecentRequest>, I>>(base?: I): GetRecentRequest {
    return GetRecentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRecentRequest>, I>>(object: I): GetRecentRequest {
    const message = createBaseGetRecentRequest();
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseSaveHistoryPromptRequest(): SaveHistoryPromptRequest {
  return { prompt: "" };
}

export const SaveHistoryPromptRequest: MessageFns<SaveHistoryPromptRequest> = {
  encode(message: SaveHistoryPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveHistoryPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveHistoryPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveHistoryPromptRequest {
    return { prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "" };
  },

  toJSON(message: SaveHistoryPromptRequest): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveHistoryPromptRequest>, I>>(base?: I): SaveHistoryPromptRequest {
    return SaveHistoryPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveHistoryPromptRequest>, I>>(object: I): SaveHistoryPromptRequest {
    const message = createBaseSaveHistoryPromptRequest();
    message.prompt = object.prompt ?? "";
    return message;
  },
};

function createBaseRepoPrompt(): RepoPrompt {
  return { repo: "", prompt: "", profileId: "" };
}

export const RepoPrompt: MessageFns<RepoPrompt> = {
  encode(message: RepoPrompt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repo !== "") {
      writer.uint32(10).string(message.repo);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    if (message.profileId !== "") {
      writer.uint32(26).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepoPrompt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepoPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepoPrompt {
    return {
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: RepoPrompt): unknown {
    const obj: any = {};
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepoPrompt>, I>>(base?: I): RepoPrompt {
    return RepoPrompt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepoPrompt>, I>>(object: I): RepoPrompt {
    const message = createBaseRepoPrompt();
    message.repo = object.repo ?? "";
    message.prompt = object.prompt ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseGetRepoPromptRequest(): GetRepoPromptRequest {
  return { repo: "" };
}

export const GetRepoPromptRequest: MessageFns<GetRepoPromptRequest> = {
  encode(message: GetRepoPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repo !== "") {
      writer.uint32(10).string(message.repo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRepoPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRepoPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRepoPromptRequest {
    return { repo: isSet(object.repo) ? globalThis.String(object.repo) : "" };
  },

  toJSON(message: GetRepoPromptRequest): unknown {
    const obj: any = {};
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetRepoPromptRequest>, I>>(base?: I): GetRepoPromptRequest {
    return GetRepoPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetRepoPromptRequest>, I>>(object: I): GetRepoPromptRequest {
    const message = createBaseGetRepoPromptRequest();
    message.repo = object.repo ?? "";
    return message;
  },
};

function createBaseSaveRepoPromptRequest(): SaveRepoPromptRequest {
  return { repo: "", prompt: "" };
}

export const SaveRepoPromptRequest: MessageFns<SaveRepoPromptRequest> = {
  encode(message: SaveRepoPromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repo !== "") {
      writer.uint32(10).string(message.repo);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SaveRepoPromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveRepoPromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveRepoPromptRequest {
    return {
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
    };
  },

  toJSON(message: SaveRepoPromptRequest): unknown {
    const obj: any = {};
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveRepoPromptRequest>, I>>(base?: I): SaveRepoPromptRequest {
    return SaveRepoPromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveRepoPromptRequest>, I>>(object: I): SaveRepoPromptRequest {
    const message = createBaseSaveRepoPromptRequest();
    message.repo = object.repo ?? "";
    message.prompt = object.prompt ?? "";
    return message;
  },
};

function createBaseSession(): Session {
  return {
    id: "",
    name: "",
    title: "",
    prompt: "",
    createTime: "",
    updateTime: "",
    state: "",
    url: "",
    requirePlanApproval: false,
    automationMode: 0,
    lastUpdated: 0,
    retryCount: 0,
    lastError: "",
    lastInteractionAt: 0,
    profileId: "",
  };
}

export const Session: MessageFns<Session> = {
  encode(message: Session, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.title !== "") {
      writer.uint32(26).string(message.title);
    }
    if (message.prompt !== "") {
      writer.uint32(34).string(message.prompt);
    }
    if (message.createTime !== "") {
      writer.uint32(42).string(message.createTime);
    }
    if (message.updateTime !== "") {
      writer.uint32(50).string(message.updateTime);
    }
    if (message.state !== "") {
      writer.uint32(58).string(message.state);
    }
    if (message.url !== "") {
      writer.uint32(66).string(message.url);
    }
    if (message.requirePlanApproval !== false) {
      writer.uint32(72).bool(message.requirePlanApproval);
    }
    if (message.automationMode !== 0) {
      writer.uint32(80).int32(message.automationMode);
    }
    if (message.lastUpdated !== 0) {
      writer.uint32(88).int64(message.lastUpdated);
    }
    if (message.retryCount !== 0) {
      writer.uint32(96).int32(message.retryCount);
    }
    if (message.lastError !== "") {
      writer.uint32(106).string(message.lastError);
    }
    if (message.lastInteractionAt !== 0) {
      writer.uint32(112).int64(message.lastInteractionAt);
    }
    if (message.profileId !== "") {
      writer.uint32(122).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Session {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateTime = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.state = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.requirePlanApproval = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.automationMode = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.lastUpdated = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.retryCount = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.lastError = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lastInteractionAt = longToNumber(reader.int64());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Session {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      createTime: isSet(object.createTime)
        ? globalThis.String(object.createTime)
        : isSet(object.create_time)
        ? globalThis.String(object.create_time)
        : "",
      updateTime: isSet(object.updateTime)
        ? globalThis.String(object.updateTime)
        : isSet(object.update_time)
        ? globalThis.String(object.update_time)
        : "",
      state: isSet(object.state) ? globalThis.String(object.state) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      requirePlanApproval: isSet(object.requirePlanApproval)
        ? globalThis.Boolean(object.requirePlanApproval)
        : isSet(object.require_plan_approval)
        ? globalThis.Boolean(object.require_plan_approval)
        : false,
      automationMode: isSet(object.automationMode)
        ? automationModeFromJSON(object.automationMode)
        : isSet(object.automation_mode)
        ? automationModeFromJSON(object.automation_mode)
        : 0,
      lastUpdated: isSet(object.lastUpdated)
        ? globalThis.Number(object.lastUpdated)
        : isSet(object.last_updated)
        ? globalThis.Number(object.last_updated)
        : 0,
      retryCount: isSet(object.retryCount)
        ? globalThis.Number(object.retryCount)
        : isSet(object.retry_count)
        ? globalThis.Number(object.retry_count)
        : 0,
      lastError: isSet(object.lastError)
        ? globalThis.String(object.lastError)
        : isSet(object.last_error)
        ? globalThis.String(object.last_error)
        : "",
      lastInteractionAt: isSet(object.lastInteractionAt)
        ? globalThis.Number(object.lastInteractionAt)
        : isSet(object.last_interaction_at)
        ? globalThis.Number(object.last_interaction_at)
        : 0,
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: Session): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.createTime !== "") {
      obj.createTime = message.createTime;
    }
    if (message.updateTime !== "") {
      obj.updateTime = message.updateTime;
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.requirePlanApproval !== false) {
      obj.requirePlanApproval = message.requirePlanApproval;
    }
    if (message.automationMode !== 0) {
      obj.automationMode = automationModeToJSON(message.automationMode);
    }
    if (message.lastUpdated !== 0) {
      obj.lastUpdated = Math.round(message.lastUpdated);
    }
    if (message.retryCount !== 0) {
      obj.retryCount = Math.round(message.retryCount);
    }
    if (message.lastError !== "") {
      obj.lastError = message.lastError;
    }
    if (message.lastInteractionAt !== 0) {
      obj.lastInteractionAt = Math.round(message.lastInteractionAt);
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Session>, I>>(base?: I): Session {
    return Session.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Session>, I>>(object: I): Session {
    const message = createBaseSession();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.title = object.title ?? "";
    message.prompt = object.prompt ?? "";
    message.createTime = object.createTime ?? "";
    message.updateTime = object.updateTime ?? "";
    message.state = object.state ?? "";
    message.url = object.url ?? "";
    message.requirePlanApproval = object.requirePlanApproval ?? false;
    message.automationMode = object.automationMode ?? 0;
    message.lastUpdated = object.lastUpdated ?? 0;
    message.retryCount = object.retryCount ?? 0;
    message.lastError = object.lastError ?? "";
    message.lastInteractionAt = object.lastInteractionAt ?? 0;
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { profileId: "" };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.profileId !== "") {
      writer.uint32(10).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsRequest {
    return {
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: ListSessionsRequest): unknown {
    const obj: any = {};
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(base?: I): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsRequest>, I>>(object: I): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      Session.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(Session.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions) ? object.sessions.map((e: any) => Session.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => Session.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(base?: I): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListSessionsResponse>, I>>(object: I): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => Session.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { id: "" };
}

export const GetSessionRequest: MessageFns<GetSessionRequest> = {
  encode(message: GetSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSessionRequest>, I>>(base?: I): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSessionRequest>, I>>(object: I): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { name: "", prompt: "", repo: "", branch: "", profileId: "" };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.prompt !== "") {
      writer.uint32(18).string(message.prompt);
    }
    if (message.repo !== "") {
      writer.uint32(26).string(message.repo);
    }
    if (message.branch !== "") {
      writer.uint32(34).string(message.branch);
    }
    if (message.profileId !== "") {
      writer.uint32(42).string(message.profileId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prompt = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.branch = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.profileId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      branch: isSet(object.branch) ? globalThis.String(object.branch) : "",
      profileId: isSet(object.profileId)
        ? globalThis.String(object.profileId)
        : isSet(object.profile_id)
        ? globalThis.String(object.profile_id)
        : "",
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.branch !== "") {
      obj.branch = message.branch;
    }
    if (message.profileId !== "") {
      obj.profileId = message.profileId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(base?: I): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateSessionRequest>, I>>(object: I): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.name = object.name ?? "";
    message.prompt = object.prompt ?? "";
    message.repo = object.repo ?? "";
    message.branch = object.branch ?? "";
    message.profileId = object.profileId ?? "";
    return message;
  },
};

function createBaseUpdateSessionRequest(): UpdateSessionRequest {
  return { id: "" };
}

export const UpdateSessionRequest: MessageFns<UpdateSessionRequest> = {
  encode(message: UpdateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSessionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: UpdateSessionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(base?: I): UpdateSessionRequest {
    return UpdateSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSessionRequest>, I>>(object: I): UpdateSessionRequest {
    const message = createBaseUpdateSessionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseDeleteSessionRequest(): DeleteSessionRequest {
  return { id: "" };
}

export const DeleteSessionRequest: MessageFns<DeleteSessionRequest> = {
  encode(message: DeleteSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSessionRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: DeleteSessionRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteSessionRequest>, I>>(base?: I): DeleteSessionRequest {
    return DeleteSessionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteSessionRequest>, I>>(object: I): DeleteSessionRequest {
    const message = createBaseDeleteSessionRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseApprovePlanRequest(): ApprovePlanRequest {
  return { id: "" };
}

export const ApprovePlanRequest: MessageFns<ApprovePlanRequest> = {
  encode(message: ApprovePlanRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovePlanRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovePlanRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovePlanRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: ApprovePlanRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApprovePlanRequest>, I>>(base?: I): ApprovePlanRequest {
    return ApprovePlanRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApprovePlanRequest>, I>>(object: I): ApprovePlanRequest {
    const message = createBaseApprovePlanRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseSendMessageRequest(): SendMessageRequest {
  return { id: "", message: "", force: false };
}

export const SendMessageRequest: MessageFns<SendMessageRequest> = {
  encode(message: SendMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMessageRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: SendMessageRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendMessageRequest>, I>>(base?: I): SendMessageRequest {
    return SendMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendMessageRequest>, I>>(object: I): SendMessageRequest {
    const message = createBaseSendMessageRequest();
    message.id = object.id ?? "";
    message.message = object.message ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

export type SettingsServiceService = typeof SettingsServiceService;
export const SettingsServiceService = {
  getSettings: {
    path: "/jules.SettingsService/GetSettings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSettingsRequest): Buffer => Buffer.from(GetSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSettingsRequest => GetSettingsRequest.decode(value),
    responseSerialize: (value: Settings): Buffer => Buffer.from(Settings.encode(value).finish()),
    responseDeserialize: (value: Buffer): Settings => Settings.decode(value),
  },
  updateSettings: {
    path: "/jules.SettingsService/UpdateSettings",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSettingsRequest): Buffer =>
      Buffer.from(UpdateSettingsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSettingsRequest => UpdateSettingsRequest.decode(value),
    responseSerialize: (value: UpdateSettingsResponse): Buffer =>
      Buffer.from(UpdateSettingsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateSettingsResponse => UpdateSettingsResponse.decode(value),
  },
} as const;

export interface SettingsServiceServer extends UntypedServiceImplementation {
  getSettings: handleUnaryCall<GetSettingsRequest, Settings>;
  updateSettings: handleUnaryCall<UpdateSettingsRequest, UpdateSettingsResponse>;
}

export interface SettingsServiceClient extends Client {
  getSettings(
    request: GetSettingsRequest,
    callback: (error: ServiceError | null, response: Settings) => void,
  ): ClientUnaryCall;
  getSettings(
    request: GetSettingsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Settings) => void,
  ): ClientUnaryCall;
  getSettings(
    request: GetSettingsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Settings) => void,
  ): ClientUnaryCall;
  updateSettings(
    request: UpdateSettingsRequest,
    callback: (error: ServiceError | null, response: UpdateSettingsResponse) => void,
  ): ClientUnaryCall;
  updateSettings(
    request: UpdateSettingsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UpdateSettingsResponse) => void,
  ): ClientUnaryCall;
  updateSettings(
    request: UpdateSettingsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UpdateSettingsResponse) => void,
  ): ClientUnaryCall;
}

export const SettingsServiceClient = makeGenericClientConstructor(
  SettingsServiceService,
  "jules.SettingsService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SettingsServiceClient;
  service: typeof SettingsServiceService;
  serviceName: string;
};

export type ProfileServiceService = typeof ProfileServiceService;
export const ProfileServiceService = {
  listProfiles: {
    path: "/jules.ProfileService/ListProfiles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListProfilesResponse): Buffer =>
      Buffer.from(ListProfilesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListProfilesResponse => ListProfilesResponse.decode(value),
  },
  createProfile: {
    path: "/jules.ProfileService/CreateProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProfileRequest): Buffer => Buffer.from(CreateProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateProfileRequest => CreateProfileRequest.decode(value),
    responseSerialize: (value: Profile): Buffer => Buffer.from(Profile.encode(value).finish()),
    responseDeserialize: (value: Buffer): Profile => Profile.decode(value),
  },
  deleteProfile: {
    path: "/jules.ProfileService/DeleteProfile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProfileRequest): Buffer => Buffer.from(DeleteProfileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteProfileRequest => DeleteProfileRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface ProfileServiceServer extends UntypedServiceImplementation {
  listProfiles: handleUnaryCall<Empty, ListProfilesResponse>;
  createProfile: handleUnaryCall<CreateProfileRequest, Profile>;
  deleteProfile: handleUnaryCall<DeleteProfileRequest, Empty>;
}

export interface ProfileServiceClient extends Client {
  listProfiles(
    request: Empty,
    callback: (error: ServiceError | null, response: ListProfilesResponse) => void,
  ): ClientUnaryCall;
  listProfiles(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProfilesResponse) => void,
  ): ClientUnaryCall;
  listProfiles(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProfilesResponse) => void,
  ): ClientUnaryCall;
  createProfile(
    request: CreateProfileRequest,
    callback: (error: ServiceError | null, response: Profile) => void,
  ): ClientUnaryCall;
  createProfile(
    request: CreateProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Profile) => void,
  ): ClientUnaryCall;
  createProfile(
    request: CreateProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Profile) => void,
  ): ClientUnaryCall;
  deleteProfile(
    request: DeleteProfileRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteProfile(
    request: DeleteProfileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteProfile(
    request: DeleteProfileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const ProfileServiceClient = makeGenericClientConstructor(
  ProfileServiceService,
  "jules.ProfileService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ProfileServiceClient;
  service: typeof ProfileServiceService;
  serviceName: string;
};

export type LogServiceService = typeof LogServiceService;
export const LogServiceService = {
  getLogs: {
    path: "/jules.LogService/GetLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLogsRequest): Buffer => Buffer.from(GetLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLogsRequest => GetLogsRequest.decode(value),
    responseSerialize: (value: GetLogsResponse): Buffer => Buffer.from(GetLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetLogsResponse => GetLogsResponse.decode(value),
  },
} as const;

export interface LogServiceServer extends UntypedServiceImplementation {
  getLogs: handleUnaryCall<GetLogsRequest, GetLogsResponse>;
}

export interface LogServiceClient extends Client {
  getLogs(
    request: GetLogsRequest,
    callback: (error: ServiceError | null, response: GetLogsResponse) => void,
  ): ClientUnaryCall;
  getLogs(
    request: GetLogsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetLogsResponse) => void,
  ): ClientUnaryCall;
  getLogs(
    request: GetLogsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetLogsResponse) => void,
  ): ClientUnaryCall;
}

export const LogServiceClient = makeGenericClientConstructor(LogServiceService, "jules.LogService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LogServiceClient;
  service: typeof LogServiceService;
  serviceName: string;
};

export type CronJobServiceService = typeof CronJobServiceService;
export const CronJobServiceService = {
  listCronJobs: {
    path: "/jules.CronJobService/ListCronJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListCronJobsResponse): Buffer =>
      Buffer.from(ListCronJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListCronJobsResponse => ListCronJobsResponse.decode(value),
  },
  createCronJob: {
    path: "/jules.CronJobService/CreateCronJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCronJobRequest): Buffer => Buffer.from(CreateCronJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateCronJobRequest => CreateCronJobRequest.decode(value),
    responseSerialize: (value: CronJob): Buffer => Buffer.from(CronJob.encode(value).finish()),
    responseDeserialize: (value: Buffer): CronJob => CronJob.decode(value),
  },
  updateCronJob: {
    path: "/jules.CronJobService/UpdateCronJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCronJobRequest): Buffer => Buffer.from(UpdateCronJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateCronJobRequest => UpdateCronJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deleteCronJob: {
    path: "/jules.CronJobService/DeleteCronJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCronJobRequest): Buffer => Buffer.from(DeleteCronJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteCronJobRequest => DeleteCronJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  executeCronJob: {
    path: "/jules.CronJobService/ExecuteCronJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteCronJobRequest): Buffer =>
      Buffer.from(ExecuteCronJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ExecuteCronJobRequest => ExecuteCronJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  toggleCronJob: {
    path: "/jules.CronJobService/ToggleCronJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ToggleCronJobRequest): Buffer => Buffer.from(ToggleCronJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ToggleCronJobRequest => ToggleCronJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface CronJobServiceServer extends UntypedServiceImplementation {
  listCronJobs: handleUnaryCall<Empty, ListCronJobsResponse>;
  createCronJob: handleUnaryCall<CreateCronJobRequest, CronJob>;
  updateCronJob: handleUnaryCall<UpdateCronJobRequest, Empty>;
  deleteCronJob: handleUnaryCall<DeleteCronJobRequest, Empty>;
  executeCronJob: handleUnaryCall<ExecuteCronJobRequest, Empty>;
  toggleCronJob: handleUnaryCall<ToggleCronJobRequest, Empty>;
}

export interface CronJobServiceClient extends Client {
  listCronJobs(
    request: Empty,
    callback: (error: ServiceError | null, response: ListCronJobsResponse) => void,
  ): ClientUnaryCall;
  listCronJobs(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListCronJobsResponse) => void,
  ): ClientUnaryCall;
  listCronJobs(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListCronJobsResponse) => void,
  ): ClientUnaryCall;
  createCronJob(
    request: CreateCronJobRequest,
    callback: (error: ServiceError | null, response: CronJob) => void,
  ): ClientUnaryCall;
  createCronJob(
    request: CreateCronJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CronJob) => void,
  ): ClientUnaryCall;
  createCronJob(
    request: CreateCronJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CronJob) => void,
  ): ClientUnaryCall;
  updateCronJob(
    request: UpdateCronJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateCronJob(
    request: UpdateCronJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateCronJob(
    request: UpdateCronJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteCronJob(
    request: DeleteCronJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteCronJob(
    request: DeleteCronJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteCronJob(
    request: DeleteCronJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  executeCronJob(
    request: ExecuteCronJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  executeCronJob(
    request: ExecuteCronJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  executeCronJob(
    request: ExecuteCronJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  toggleCronJob(
    request: ToggleCronJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  toggleCronJob(
    request: ToggleCronJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  toggleCronJob(
    request: ToggleCronJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const CronJobServiceClient = makeGenericClientConstructor(
  CronJobServiceService,
  "jules.CronJobService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CronJobServiceClient;
  service: typeof CronJobServiceService;
  serviceName: string;
};

export type JobServiceService = typeof JobServiceService;
export const JobServiceService = {
  listJobs: {
    path: "/jules.JobService/ListJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListJobsResponse): Buffer => Buffer.from(ListJobsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListJobsResponse => ListJobsResponse.decode(value),
  },
  getJob: {
    path: "/jules.JobService/GetJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetJobRequest): Buffer => Buffer.from(GetJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetJobRequest => GetJobRequest.decode(value),
    responseSerialize: (value: Job): Buffer => Buffer.from(Job.encode(value).finish()),
    responseDeserialize: (value: Buffer): Job => Job.decode(value),
  },
  createJob: {
    path: "/jules.JobService/CreateJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateJobRequest): Buffer => Buffer.from(CreateJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateJobRequest => CreateJobRequest.decode(value),
    responseSerialize: (value: Job): Buffer => Buffer.from(Job.encode(value).finish()),
    responseDeserialize: (value: Buffer): Job => Job.decode(value),
  },
  createManyJobs: {
    path: "/jules.JobService/CreateManyJobs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateManyJobsRequest): Buffer =>
      Buffer.from(CreateManyJobsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateManyJobsRequest => CreateManyJobsRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  updateJob: {
    path: "/jules.JobService/UpdateJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateJobRequest): Buffer => Buffer.from(UpdateJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateJobRequest => UpdateJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deleteJob: {
    path: "/jules.JobService/DeleteJob",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteJobRequest): Buffer => Buffer.from(DeleteJobRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteJobRequest => DeleteJobRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface JobServiceServer extends UntypedServiceImplementation {
  listJobs: handleUnaryCall<Empty, ListJobsResponse>;
  getJob: handleUnaryCall<GetJobRequest, Job>;
  createJob: handleUnaryCall<CreateJobRequest, Job>;
  createManyJobs: handleUnaryCall<CreateManyJobsRequest, Empty>;
  updateJob: handleUnaryCall<UpdateJobRequest, Empty>;
  deleteJob: handleUnaryCall<DeleteJobRequest, Empty>;
}

export interface JobServiceClient extends Client {
  listJobs(request: Empty, callback: (error: ServiceError | null, response: ListJobsResponse) => void): ClientUnaryCall;
  listJobs(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListJobsResponse) => void,
  ): ClientUnaryCall;
  listJobs(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListJobsResponse) => void,
  ): ClientUnaryCall;
  getJob(request: GetJobRequest, callback: (error: ServiceError | null, response: Job) => void): ClientUnaryCall;
  getJob(
    request: GetJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  getJob(
    request: GetJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  createJob(request: CreateJobRequest, callback: (error: ServiceError | null, response: Job) => void): ClientUnaryCall;
  createJob(
    request: CreateJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  createJob(
    request: CreateJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Job) => void,
  ): ClientUnaryCall;
  createManyJobs(
    request: CreateManyJobsRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyJobs(
    request: CreateManyJobsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyJobs(
    request: CreateManyJobsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateJob(
    request: UpdateJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateJob(
    request: UpdateJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateJob(
    request: UpdateJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteJob(
    request: DeleteJobRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteJob(
    request: DeleteJobRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteJob(
    request: DeleteJobRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const JobServiceClient = makeGenericClientConstructor(JobServiceService, "jules.JobService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): JobServiceClient;
  service: typeof JobServiceService;
  serviceName: string;
};

export type PromptServiceService = typeof PromptServiceService;
export const PromptServiceService = {
  /** Predefined Prompts */
  listPredefinedPrompts: {
    path: "/jules.PromptService/ListPredefinedPrompts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListPredefinedPromptsResponse): Buffer =>
      Buffer.from(ListPredefinedPromptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPredefinedPromptsResponse => ListPredefinedPromptsResponse.decode(value),
  },
  getPredefinedPrompt: {
    path: "/jules.PromptService/GetPredefinedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPromptRequest): Buffer => Buffer.from(GetPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPromptRequest => GetPromptRequest.decode(value),
    responseSerialize: (value: PredefinedPrompt): Buffer => Buffer.from(PredefinedPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): PredefinedPrompt => PredefinedPrompt.decode(value),
  },
  createPredefinedPrompt: {
    path: "/jules.PromptService/CreatePredefinedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePromptRequest): Buffer => Buffer.from(CreatePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePromptRequest => CreatePromptRequest.decode(value),
    responseSerialize: (value: PredefinedPrompt): Buffer => Buffer.from(PredefinedPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): PredefinedPrompt => PredefinedPrompt.decode(value),
  },
  createManyPredefinedPrompts: {
    path: "/jules.PromptService/CreateManyPredefinedPrompts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateManyPromptsRequest): Buffer =>
      Buffer.from(CreateManyPromptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateManyPromptsRequest => CreateManyPromptsRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  updatePredefinedPrompt: {
    path: "/jules.PromptService/UpdatePredefinedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePromptRequest): Buffer => Buffer.from(UpdatePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePromptRequest => UpdatePromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deletePredefinedPrompt: {
    path: "/jules.PromptService/DeletePredefinedPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePromptRequest): Buffer => Buffer.from(DeletePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePromptRequest => DeletePromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Quick Replies */
  listQuickReplies: {
    path: "/jules.PromptService/ListQuickReplies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListPredefinedPromptsResponse): Buffer =>
      Buffer.from(ListPredefinedPromptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListPredefinedPromptsResponse => ListPredefinedPromptsResponse.decode(value),
  },
  getQuickReply: {
    path: "/jules.PromptService/GetQuickReply",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPromptRequest): Buffer => Buffer.from(GetPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetPromptRequest => GetPromptRequest.decode(value),
    responseSerialize: (value: PredefinedPrompt): Buffer => Buffer.from(PredefinedPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): PredefinedPrompt => PredefinedPrompt.decode(value),
  },
  createQuickReply: {
    path: "/jules.PromptService/CreateQuickReply",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePromptRequest): Buffer => Buffer.from(CreatePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreatePromptRequest => CreatePromptRequest.decode(value),
    responseSerialize: (value: PredefinedPrompt): Buffer => Buffer.from(PredefinedPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): PredefinedPrompt => PredefinedPrompt.decode(value),
  },
  createManyQuickReplies: {
    path: "/jules.PromptService/CreateManyQuickReplies",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateManyPromptsRequest): Buffer =>
      Buffer.from(CreateManyPromptsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateManyPromptsRequest => CreateManyPromptsRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  updateQuickReply: {
    path: "/jules.PromptService/UpdateQuickReply",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePromptRequest): Buffer => Buffer.from(UpdatePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdatePromptRequest => UpdatePromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deleteQuickReply: {
    path: "/jules.PromptService/DeleteQuickReply",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePromptRequest): Buffer => Buffer.from(DeletePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeletePromptRequest => DeletePromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Global Prompt */
  getGlobalPrompt: {
    path: "/jules.PromptService/GetGlobalPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: GlobalPrompt): Buffer => Buffer.from(GlobalPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): GlobalPrompt => GlobalPrompt.decode(value),
  },
  saveGlobalPrompt: {
    path: "/jules.PromptService/SaveGlobalPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SaveGlobalPromptRequest): Buffer =>
      Buffer.from(SaveGlobalPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SaveGlobalPromptRequest => SaveGlobalPromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** History Prompts */
  listHistoryPrompts: {
    path: "/jules.PromptService/ListHistoryPrompts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ListHistoryPromptsResponse): Buffer =>
      Buffer.from(ListHistoryPromptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHistoryPromptsResponse => ListHistoryPromptsResponse.decode(value),
  },
  getRecentHistoryPrompts: {
    path: "/jules.PromptService/GetRecentHistoryPrompts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRecentRequest): Buffer => Buffer.from(GetRecentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRecentRequest => GetRecentRequest.decode(value),
    responseSerialize: (value: ListHistoryPromptsResponse): Buffer =>
      Buffer.from(ListHistoryPromptsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListHistoryPromptsResponse => ListHistoryPromptsResponse.decode(value),
  },
  saveHistoryPrompt: {
    path: "/jules.PromptService/SaveHistoryPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SaveHistoryPromptRequest): Buffer =>
      Buffer.from(SaveHistoryPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SaveHistoryPromptRequest => SaveHistoryPromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  /** Repo Prompts */
  getRepoPrompt: {
    path: "/jules.PromptService/GetRepoPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRepoPromptRequest): Buffer => Buffer.from(GetRepoPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRepoPromptRequest => GetRepoPromptRequest.decode(value),
    responseSerialize: (value: RepoPrompt): Buffer => Buffer.from(RepoPrompt.encode(value).finish()),
    responseDeserialize: (value: Buffer): RepoPrompt => RepoPrompt.decode(value),
  },
  saveRepoPrompt: {
    path: "/jules.PromptService/SaveRepoPrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SaveRepoPromptRequest): Buffer =>
      Buffer.from(SaveRepoPromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SaveRepoPromptRequest => SaveRepoPromptRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface PromptServiceServer extends UntypedServiceImplementation {
  /** Predefined Prompts */
  listPredefinedPrompts: handleUnaryCall<Empty, ListPredefinedPromptsResponse>;
  getPredefinedPrompt: handleUnaryCall<GetPromptRequest, PredefinedPrompt>;
  createPredefinedPrompt: handleUnaryCall<CreatePromptRequest, PredefinedPrompt>;
  createManyPredefinedPrompts: handleUnaryCall<CreateManyPromptsRequest, Empty>;
  updatePredefinedPrompt: handleUnaryCall<UpdatePromptRequest, Empty>;
  deletePredefinedPrompt: handleUnaryCall<DeletePromptRequest, Empty>;
  /** Quick Replies */
  listQuickReplies: handleUnaryCall<Empty, ListPredefinedPromptsResponse>;
  getQuickReply: handleUnaryCall<GetPromptRequest, PredefinedPrompt>;
  createQuickReply: handleUnaryCall<CreatePromptRequest, PredefinedPrompt>;
  createManyQuickReplies: handleUnaryCall<CreateManyPromptsRequest, Empty>;
  updateQuickReply: handleUnaryCall<UpdatePromptRequest, Empty>;
  deleteQuickReply: handleUnaryCall<DeletePromptRequest, Empty>;
  /** Global Prompt */
  getGlobalPrompt: handleUnaryCall<Empty, GlobalPrompt>;
  saveGlobalPrompt: handleUnaryCall<SaveGlobalPromptRequest, Empty>;
  /** History Prompts */
  listHistoryPrompts: handleUnaryCall<Empty, ListHistoryPromptsResponse>;
  getRecentHistoryPrompts: handleUnaryCall<GetRecentRequest, ListHistoryPromptsResponse>;
  saveHistoryPrompt: handleUnaryCall<SaveHistoryPromptRequest, Empty>;
  /** Repo Prompts */
  getRepoPrompt: handleUnaryCall<GetRepoPromptRequest, RepoPrompt>;
  saveRepoPrompt: handleUnaryCall<SaveRepoPromptRequest, Empty>;
}

export interface PromptServiceClient extends Client {
  /** Predefined Prompts */
  listPredefinedPrompts(
    request: Empty,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  listPredefinedPrompts(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  listPredefinedPrompts(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  getPredefinedPrompt(
    request: GetPromptRequest,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  getPredefinedPrompt(
    request: GetPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  getPredefinedPrompt(
    request: GetPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createPredefinedPrompt(
    request: CreatePromptRequest,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createPredefinedPrompt(
    request: CreatePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createPredefinedPrompt(
    request: CreatePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createManyPredefinedPrompts(
    request: CreateManyPromptsRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyPredefinedPrompts(
    request: CreateManyPromptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyPredefinedPrompts(
    request: CreateManyPromptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updatePredefinedPrompt(
    request: UpdatePromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updatePredefinedPrompt(
    request: UpdatePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updatePredefinedPrompt(
    request: UpdatePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deletePredefinedPrompt(
    request: DeletePromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deletePredefinedPrompt(
    request: DeletePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deletePredefinedPrompt(
    request: DeletePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Quick Replies */
  listQuickReplies(
    request: Empty,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  listQuickReplies(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  listQuickReplies(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListPredefinedPromptsResponse) => void,
  ): ClientUnaryCall;
  getQuickReply(
    request: GetPromptRequest,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  getQuickReply(
    request: GetPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  getQuickReply(
    request: GetPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createQuickReply(
    request: CreatePromptRequest,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createQuickReply(
    request: CreatePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createQuickReply(
    request: CreatePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: PredefinedPrompt) => void,
  ): ClientUnaryCall;
  createManyQuickReplies(
    request: CreateManyPromptsRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyQuickReplies(
    request: CreateManyPromptsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createManyQuickReplies(
    request: CreateManyPromptsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateQuickReply(
    request: UpdatePromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateQuickReply(
    request: UpdatePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateQuickReply(
    request: UpdatePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteQuickReply(
    request: DeletePromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteQuickReply(
    request: DeletePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteQuickReply(
    request: DeletePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Global Prompt */
  getGlobalPrompt(
    request: Empty,
    callback: (error: ServiceError | null, response: GlobalPrompt) => void,
  ): ClientUnaryCall;
  getGlobalPrompt(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GlobalPrompt) => void,
  ): ClientUnaryCall;
  getGlobalPrompt(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GlobalPrompt) => void,
  ): ClientUnaryCall;
  saveGlobalPrompt(
    request: SaveGlobalPromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveGlobalPrompt(
    request: SaveGlobalPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveGlobalPrompt(
    request: SaveGlobalPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** History Prompts */
  listHistoryPrompts(
    request: Empty,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  listHistoryPrompts(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  listHistoryPrompts(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  getRecentHistoryPrompts(
    request: GetRecentRequest,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  getRecentHistoryPrompts(
    request: GetRecentRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  getRecentHistoryPrompts(
    request: GetRecentRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListHistoryPromptsResponse) => void,
  ): ClientUnaryCall;
  saveHistoryPrompt(
    request: SaveHistoryPromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveHistoryPrompt(
    request: SaveHistoryPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveHistoryPrompt(
    request: SaveHistoryPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Repo Prompts */
  getRepoPrompt(
    request: GetRepoPromptRequest,
    callback: (error: ServiceError | null, response: RepoPrompt) => void,
  ): ClientUnaryCall;
  getRepoPrompt(
    request: GetRepoPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RepoPrompt) => void,
  ): ClientUnaryCall;
  getRepoPrompt(
    request: GetRepoPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RepoPrompt) => void,
  ): ClientUnaryCall;
  saveRepoPrompt(
    request: SaveRepoPromptRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveRepoPrompt(
    request: SaveRepoPromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  saveRepoPrompt(
    request: SaveRepoPromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const PromptServiceClient = makeGenericClientConstructor(
  PromptServiceService,
  "jules.PromptService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): PromptServiceClient;
  service: typeof PromptServiceService;
  serviceName: string;
};

export type SessionServiceService = typeof SessionServiceService;
export const SessionServiceService = {
  listSessions: {
    path: "/jules.SessionService/ListSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionsRequest): Buffer => Buffer.from(ListSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionsRequest => ListSessionsRequest.decode(value),
    responseSerialize: (value: ListSessionsResponse): Buffer =>
      Buffer.from(ListSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionsResponse => ListSessionsResponse.decode(value),
  },
  getSession: {
    path: "/jules.SessionService/GetSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSessionRequest): Buffer => Buffer.from(GetSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSessionRequest => GetSessionRequest.decode(value),
    responseSerialize: (value: Session): Buffer => Buffer.from(Session.encode(value).finish()),
    responseDeserialize: (value: Buffer): Session => Session.decode(value),
  },
  createSession: {
    path: "/jules.SessionService/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest): Buffer => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSessionRequest => CreateSessionRequest.decode(value),
    responseSerialize: (value: Session): Buffer => Buffer.from(Session.encode(value).finish()),
    responseDeserialize: (value: Buffer): Session => Session.decode(value),
  },
  updateSession: {
    path: "/jules.SessionService/UpdateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateSessionRequest): Buffer => Buffer.from(UpdateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateSessionRequest => UpdateSessionRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  deleteSession: {
    path: "/jules.SessionService/DeleteSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteSessionRequest): Buffer => Buffer.from(DeleteSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteSessionRequest => DeleteSessionRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  approvePlan: {
    path: "/jules.SessionService/ApprovePlan",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ApprovePlanRequest): Buffer => Buffer.from(ApprovePlanRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ApprovePlanRequest => ApprovePlanRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  sendMessage: {
    path: "/jules.SessionService/SendMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendMessageRequest): Buffer => Buffer.from(SendMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendMessageRequest => SendMessageRequest.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
} as const;

export interface SessionServiceServer extends UntypedServiceImplementation {
  listSessions: handleUnaryCall<ListSessionsRequest, ListSessionsResponse>;
  getSession: handleUnaryCall<GetSessionRequest, Session>;
  createSession: handleUnaryCall<CreateSessionRequest, Session>;
  updateSession: handleUnaryCall<UpdateSessionRequest, Empty>;
  deleteSession: handleUnaryCall<DeleteSessionRequest, Empty>;
  approvePlan: handleUnaryCall<ApprovePlanRequest, Empty>;
  sendMessage: handleUnaryCall<SendMessageRequest, Empty>;
}

export interface SessionServiceClient extends Client {
  listSessions(
    request: ListSessionsRequest,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Session) => void,
  ): ClientUnaryCall;
  updateSession(
    request: UpdateSessionRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSession(
    request: UpdateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  updateSession(
    request: UpdateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteSession(
    request: DeleteSessionRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteSession(
    request: DeleteSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  deleteSession(
    request: DeleteSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  approvePlan(
    request: ApprovePlanRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  approvePlan(
    request: ApprovePlanRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  approvePlan(
    request: ApprovePlanRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  sendMessage(
    request: SendMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const SessionServiceClient = makeGenericClientConstructor(
  SessionServiceService,
  "jules.SessionService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SessionServiceClient;
  service: typeof SessionServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
